<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一大三千的博客</title>
  
  <subtitle>yidasanqian&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yidasanqian.github.io/"/>
  <updated>2019-06-25T02:20:27.418Z</updated>
  <id>https://yidasanqian.github.io/</id>
  
  <author>
    <name>yidasanqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Java并发编程的艺术》读书笔记（二）</title>
    <link href="https://yidasanqian.github.io/2019/06/25/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://yidasanqian.github.io/2019/06/25/《Java并发编程的艺术》读书笔记（二）/</id>
    <published>2019-06-25T01:26:50.613Z</published>
    <updated>2019-06-25T02:20:27.418Z</updated>
    
    <content type="html"><![CDATA[<p>笔记内容包含第四章～第六章</p><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="Java线程状态变迁"><a href="#Java线程状态变迁" class="headerlink" title="Java线程状态变迁"></a>Java线程状态变迁</h3><p><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/Java线程状态变迁图.jpg" width="60%" height="40%"></p><p>由上图中可以看到，线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。<br>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。<br>线程在执行Runnable的run()方法之后将会进入到终止状态。</p><blockquote><p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。<br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在<br>java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p></blockquote><h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。<br>可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p><blockquote><p>注意: Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p></blockquote><h3 id="理解中断"><a href="#理解中断" class="headerlink" title="理解中断"></a>理解中断</h3><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。<br>中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的<code>interrupt()</code>方法对其进行中断操作。</p><p>线程通过检查自身是否被中断来进行响应，线程通过方法<code>isInterrupted()</code>来进行判断是否被中断，也可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，<br>即使该线程被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回false。</p><p>从Java的API中可以看到，许多声明抛出<code>InterruptedException</code>的方法（例如<code>Thread.sleep(longmillis)</code>方法）<br>这些方法在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static final void second(long seconds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // 抛出InterruptedException之前会清除中断标识位</span><br><span class="line">        System.out.println(&quot;throws intercepted exception&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过期的suspend-、resume-和stop-方法"><a href="#过期的suspend-、resume-和stop-方法" class="headerlink" title="过期的suspend()、resume()和stop()方法"></a>过期的suspend()、resume()和stop()方法</h3><p>不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p><p>因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而暂停和恢复操作可以用后面提到的等待/通知机制来替代。</p><h3 id="优雅的关闭线程"><a href="#优雅的关闭线程" class="headerlink" title="优雅的关闭线程"></a>优雅的关闭线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Shutdown &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runner one = new Runner();</span><br><span class="line">        Thread countThread = new Thread(one, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        System.out.println(&quot;Count Thread isInterrupted: &quot; + countThread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        Runner two = new Runner();</span><br><span class="line">        countThread = new Thread(two, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        two.cancel();</span><br><span class="line">        System.out.println(&quot;Count Thread isInterrupted: &quot; + countThread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Runner implements Runnable &#123;</span><br><span class="line">        private long             i;</span><br><span class="line">        private volatile boolean on = true;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Count i = &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void cancel() &#123;</span><br><span class="line">            on = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。<br>这种通过<strong>标识位</strong>或者<strong>中断操作</strong>的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p><h2 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h2><p>Java支持多个线程同时访问一个对象或者对象的成员变量，由于<strong>每个线程可以拥有这个变量的拷贝</strong>（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p><p>关键字<strong>volatile</strong>可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能<strong>保证所有线程对变量访问的可见性</strong>。</p><p>关键字<strong>synchronized</strong>可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它<strong>保证了线程对变量访问的可见性和排他性</strong>。</p><p><strong>等待/通知机制</strong>，是指一个线程A调用了对象obj的wait()方法进入等待状态，而另一个线程B调用了对象obj的notify()<br>或者notifyAll()方法，线程A收到通知后从对象obj的wait()方法返回，进而执行后续操作。</p><p>上述两个线程通过对象obj来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p><h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>Lock的使用的方式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p><p><strong>不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</strong></p><h3 id="同步器-AbstractQueuedSynchronizer"><a href="#同步器-AbstractQueuedSynchronizer" class="headerlink" title="同步器 AbstractQueuedSynchronizer"></a>同步器 AbstractQueuedSynchronizer</h3><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p><p>可以这样理解二者之间的关系：</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；</li><li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li></ul><p>锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p><p>独占式同步状态获取和释放过程总结：</p><p>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；<br>移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用<br>tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p><h3 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁 ReentrantLock"></a>重入锁 ReentrantLock</h3><p>顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。<br>除此之外，该锁还支持获取锁时的公平和非公平性选择。</p><p>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p><p>这里提到一个锁获取的公平性问题，如果在<strong>绝对时间</strong>上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p><p>事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>排他锁（如ReentrantLock），这些锁在同一时刻只允许一个线程进行访问，而读写锁在<strong>同一时刻可以允许多个读线程访问</strong>，但是在<strong>写线程访问时，所有的读线程和其他写线程均被阻塞</strong>。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是<strong>ReentrantReadWriteLock</strong>。</p><p><strong>写锁是一个支持重进入的排它锁</strong>。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><p><strong>读锁是一个支持重进入的共享锁</strong>，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</p><h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>锁降级指的是写锁降级成为读锁。<strong>锁降级是指当前拥有写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong></p><h2 id="并发容器和框架"><a href="#并发容器和框架" class="headerlink" title="并发容器和框架"></a>并发容器和框架</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是线程安全且高效的HashMap。</p><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p><p>（1）线程不安全的HashMap</p><p>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p><p>HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><p>（2）效率低下的HashTable</p><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。</p><p>如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><p>（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率</p><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的<strong>锁分段技术</strong>：</p><p>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。</p><p>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。<br><strong>非阻塞的实现方式则可以使用循环CAS的方式来实现</strong>。</p><p>ConcurrentLinkedQueue是一个<strong>基于链接节点的无界线程安全队列</strong>，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。</p><p>它采用了“wait-free”算法（即CAS算法）来实现，该算法在Michael&amp;Scott算法上进行了一些修改。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p><p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><p>JDK 7提供了7个阻塞队列，如下：</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的无界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><p><strong>通知模式</strong>，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</p><p><img src="https://static001.infoq.cn/resource/image/2b/09/2be16e00a8ee6f6c7b738817f003e609.png" alt="fork/join运行流程图"></p><p>图源：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9mb3JrLWpvaW4taW50cm9kdWN0aW9u" title="https://www.infoq.cn/article/fork-join-introduction">聊聊并发（八）——Fork/Join 框架介绍<i class="fa fa-external-link"></i></span></p><p><strong>工作窃取（work-stealing）算法</strong>是指某个线程从其他队列里窃取任务来执行。</p><p>优点：充分利用线程进行并行计算，减少了线程间的竞争。</p><p>缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><p><img src="https://static.oschina.net/uploads/space/2018/0528/200557_UPOJ_568818.png" width="60%" height="40%" placeholder="工作窃取算法图"></p><p>图源：<span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9sZWVqdW4yMDA1L2Jsb2cvMjY4NjM0" title="https://my.oschina.net/leejun2005/blog/268634">图解 Fork/Join<i class="fa fa-external-link"></i></span></p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔记内容包含第四章～第六章&lt;/p&gt;&lt;h2 id=&quot;线程简介&quot;&gt;&lt;a href=&quot;#线程简介&quot; class=&quot;headerlink&quot; title=&quot;线程简介&quot;&gt;&lt;/a&gt;线程简介&lt;/h2&gt;&lt;h3 id=&quot;Java线程状态变迁&quot;&gt;&lt;a href=&quot;#Java线程状态变迁&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://yidasanqian.github.io/categories/Java/"/>
    
    
      <category term="Concurrency" scheme="https://yidasanqian.github.io/tags/Concurrency/"/>
    
      <category term="并发" scheme="https://yidasanqian.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程状态" scheme="https://yidasanqian.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    
      <category term="Daemon线程" scheme="https://yidasanqian.github.io/tags/Daemon%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程中断" scheme="https://yidasanqian.github.io/tags/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    
      <category term="关闭线程" scheme="https://yidasanqian.github.io/tags/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程通讯" scheme="https://yidasanqian.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF/"/>
    
      <category term="重入锁" scheme="https://yidasanqian.github.io/tags/%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
      <category term="读写锁" scheme="https://yidasanqian.github.io/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
      <category term="通知模式" scheme="https://yidasanqian.github.io/tags/%E9%80%9A%E7%9F%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="并发容器" scheme="https://yidasanqian.github.io/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Fork/Join框架" scheme="https://yidasanqian.github.io/tags/Fork-Join%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>《Java并发编程的艺术》读书笔记（一）</title>
    <link href="https://yidasanqian.github.io/2019/06/14/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://yidasanqian.github.io/2019/06/14/《Java并发编程的艺术》读书笔记（一）/</id>
    <published>2019-06-14T06:01:40.489Z</published>
    <updated>2019-06-14T07:11:35.670Z</updated>
    
    <content type="html"><![CDATA[<p>笔记内容包含第一章～第三章</p><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换也会影响多线程的执行速度。</p><p>dump线程信息里WAITING(on object monitor)的线程少了，系统上下文切换的次数就会少，因为每一次从WAITTING到RUNNABLE都会进行一次上下文的切换。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="避免死锁的常见方法"><a href="#避免死锁的常见方法" class="headerlink" title="避免死锁的常见方法"></a>避免死锁的常见方法</h3><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性协议</strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><h3 id="volatile的两条实现原则"><a href="#volatile的两条实现原则" class="headerlink" title="volatile的两条实现原则"></a>volatile的两条实现原则</h3><ul><li>Lock前缀指令会引起处理器缓存回写到内存</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized实现同步的基础，Java中的每一个对象都可以作为锁：</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><p>Synchonized在JVM里的实现原理，JVM基于进入和退出<strong>Monitor对象</strong>来实现方法同步和代码块同步，但两者的实现细节不一样。</p><p>代码块同步是使用<strong>monitorenter</strong>和<strong>monitorexit</strong>指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</p><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。</p><p>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><p>synchronized用的锁是存在<span class="exturl" data-url="aHR0cHM6Ly93d3cuaG9sbGlzY2h1YW5nLmNvbS9hcmNoaXZlcy8xOTUz" title="https://www.hollischuang.com/archives/1953">Java对象头<i class="fa fa-external-link"></i></span>里的。</p><h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><p>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p><p>下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程：<br><img src="http://ifeve.com/wp-content/uploads/2012/10/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png" alt="Java锁的升级"></p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><blockquote><p>CAS 即Compare And Swap</p></blockquote><p>通过锁实现原子操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (A) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用循环CAS实现原子操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void safeCount() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int i = atomicI.get();</span><br><span class="line">        boolean suc = atomicI.compareAndSet(i, ++i);</span><br><span class="line">        if (suc) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题：</p><ol><li>ABA问题：如果一个值原来是A，变成了B，又变成了A。java.util.concurrent.atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</li><li>循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li><li>只能保证一个共享变量的原子操作：java.util.concurrent.atomic.AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li></ol><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>线程之间的通信机制有两种：</p><ol><li><strong>共享内存</strong>: 线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。</li><li>消息传递: 线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</li></ol><p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。</p><p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><p>为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型：</p><ol><li><strong>编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行的重排序</strong>：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><strong>内存系统的重排序</strong>：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如下图所示：<br><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/从源码到最终执行的指令序列图.png"></p><p><strong>重排序</strong>是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p><p><strong>as-if-serial语义</strong>的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p><p>为了遵守as-if-serial语义，<strong>编译器和处理器不会对存在数据依赖关系的操作做重排序</strong>，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p>在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p><p>如果程序是正确同步的，程序的执行将具有顺序一致性（Sequentially Consistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p><p>顺序一致性内存模型有两大特性：</p><ol><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ol><p>每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为<strong>总线事务（BusTransaction）</strong>。<br>总线事务包括读事务（Read Transaction）和写事务（Write Transaction）。</p><p><strong>读事务</strong>从内存传送数据到处理器，<strong>写事务</strong>从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。</p><p>在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写操作具有原子性。</p><p>当JVM在这种处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。</p><h3 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h3><h4 id="volatile-1"><a href="#volatile-1" class="headerlink" title="volatile"></a>volatile</h4><p>锁的<strong>happens-before</strong>规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p><p>特性:</p><ol><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li></ol><p>volatile写的内存语义如下：</p><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p><p>volatile读的内存语义如下：</p><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>前文提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下表是JMM针对编译器制定的<strong>volatile重排序规则表</strong>：<br><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/volatile重排序规则表.jpg"><br>从上表我们可以看出：</p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li></ul><p>对volatile写和volatile读的内存语义做个总结：</p><ul><li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。</li><li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</li><li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替锁，请一定谨慎，具体详情请参阅Brian Goetz的文章《Java理论与实践：正确使用Volatile变量》。</p><h4 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h4><p>锁释放和锁获取的内存语义总结：</p><ul><li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li><li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li><li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><blockquote><p>锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p></blockquote><p>借助<code>ReentrantLock</code>类的源代码，来分析锁内存语义的具体实现机制。</p><p>在<code>ReentrantLock</code>中，调用lock()方法获取锁；调用unlock()方法释放锁。</p><p><code>ReentrantLock</code>的实现依赖于Java同步器框架<code>AbstractQueuedSynchronizer</code>（本文简称之为AQS）。<br>AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是<code>ReentrantLock</code>内存语义实现的关键。</p><p><code>ReentrantLock</code>分为公平锁和非公平锁，我们首先分析<strong>公平锁</strong>。<br>使用公平锁时，加锁方法lock()调用轨迹如下：</p><ol><li>ReentrantLock:lock()</li><li>FairSync:lock()</li><li>AbstractQueuedSynchronizer:acquire(int arg)</li><li>ReentrantLock:tryAcquire(int acquires)</li></ol><p>在第4步真正开始加锁，下面是该方法的源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();     // 获取锁的开始，首先读volatile变量state</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源代码中我们可以看出，加锁方法首先读volatile变量<code>state</code>。</p><p>在使用公平锁时，解锁方法unlock()调用轨迹如下:</p><ol><li>ReentrantLock:unlock()</li><li>AbstractQueuedSynchronizer:release(int arg)</li><li>Sync:tryRelease(int releases)</li></ol><p>在第3步真正开始释放锁，下面是该方法的源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);        // 释放锁的最后，写volatile变量state</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源代码可以看出，在释放锁的最后写volatile变量state。</p><p><strong>非公平锁</strong>的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p><p>使用非公平锁时，加锁方法lock()调用轨迹如下:</p><ol><li>ReentrantLock:lock()</li><li>NonfairSync:lock()</li><li>AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)</li></ol><p>在第3步真正开始加锁，下面是该方法的源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法以原子操作的方式更新state变量,JDK文档对该方法的说明如下：<br>如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。<br>此操作具有volatile读和写的内存语义。</p><p>经过上面的分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。</p><p>公平锁和非公平锁的内存语义总结:</p><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li><li>公平锁获取时，首先会去读volatile变量。</li><li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</li></ul><p>锁释放-获取的内存语义的实现至少有下面两种方式：</p><ol><li>利用volatile变量的写-读所具有的内存语义。</li><li>利用CAS所附带的volatile读和volatile写的内存语义</li></ol><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出（escape）”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p><p>要得到这个效果，还需要一个保证：<br>在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p><p>为了说明问题，让我们来看下面的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    final int                          i;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line"></span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1;       // 1 写final域</span><br><span class="line">        obj = this;  // 2 this引用在此&quot;逸出&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reader() &#123;</span><br><span class="line">        if (obj != null) &#123;      // 3</span><br><span class="line">            int temp = obj.i;   // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个线程，线程a执行writer方法，由于<strong>操作1和2可能被重排序</strong>，当线程b执行reader方法时获取到的final域可能还是未初始化的。</p><p>因此，在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。<strong>在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</strong></p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。<strong>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法</strong>（也就是说，JMM允许这种重排序）。</li></ol><p>happens-before关系本质上和as-if-serial语义是一回事，都是为了在<strong>不改变程序执行结果</strong>的前提下，尽可能地提高程序执行的并行度。</p><p>happens-before规则：</p><ol><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ol><h4 id="双重检查锁定与延迟初始化"><a href="#双重检查锁定与延迟初始化" class="headerlink" title="双重检查锁定与延迟初始化"></a>双重检查锁定与延迟初始化</h4><p>在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只在使用这些对象时才进行初始化。此时，可能会采用延迟初始化。但要正确实现线程安全的延迟初始化需要一些技巧，否则很容易出现问题。</p><p>比如，下面是非线程安全的延迟初始化对象的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)           // 1：A线程执行</span><br><span class="line">            instance = new Instance();  // 2：B线程执行</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instance=new Singleton()</code>创建了一个对象。这一行代码可以分解为如下的3行伪代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  // 1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory); // 2：初始化对象</span><br><span class="line">instance = memory;    // 3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure><p>上面3行伪代码中的2和3之间，可能会被重排序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();    // 1：分配对象的内存空间</span><br><span class="line">instance = memory;      // 3：设置instance指向刚分配的内存地址 注意，此时对象还没有被初始化！</span><br><span class="line">ctorInstance(memory);   // 2：初始化对象</span><br></pre></td></tr></table></figure><p>上面3行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反<strong>Java语言规范</strong>里的intra-thread semantics。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。</p><p><strong>intra-thread semantics</strong>允许那些在单线程内，不会改变单线程程序执行结果的重排序。</p><p>因此在UnsafeLazyInitialization类中，假设A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化，最终导致创建了多个对象实例。</p><p>可以对getInstance()方法做同步处理来实现线程安全的延迟初始化。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line"></span><br><span class="line">    public synchronized static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于对getInstance()方法做了同步处理，synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。反之，如果getInstance()方法不会被多个线程频繁的调用，那么这个延迟初始化方案将能提供令人满意的性能。</p><p>在早期的JVM中，synchronized（甚至是无竞争的synchronized）存在巨大的性能开销。因此出现了<strong>双重检查锁定</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123;                     //1</span><br><span class="line">    private static Instance instance;                   //2</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance() &#123;              //3</span><br><span class="line">        // 在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象</span><br><span class="line">        if (instance == null) &#123;                         //4:第一次检查</span><br><span class="line">            // 多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123; //5:加锁</span><br><span class="line">                if (instance == null)                   //6:第二次检查</span><br><span class="line">                    instance = new Instance();          //7:问题的根源出在这里</span><br><span class="line">            &#125;                                           //8</span><br><span class="line">        &#125;                                               //9</span><br><span class="line">        return instance;                                //10</span><br><span class="line">    &#125;                                                   //11</span><br><span class="line"></span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面代码所示，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。</p><p>前面提到线程A执行到第7步代码可能会发生重排序。如果发生重排序，另一个并发执行的线程B就有可能在第4步判断instance不为null。<br>线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。</p><p>下图是这个场景的具体执行时序：<br><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/重排序多线程执行时序表.png"><br>这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象，因此可能会导致线程安全问题。</p><p>可以看<span class="exturl" data-url="aHR0cHM6Ly93d3cub3NjaGluYS5uZXQvcXVlc3Rpb24vMjU1MTcyNV8yMjY5Mjk5" title="https://www.oschina.net/question/2551725_2269299">这个帖子<i class="fa fa-external-link"></i></span>加强理解。</p><p>有两个办法来实现线程安全的延迟初始化：</p><ol><li>不允许A2和A3重排序 — 基于volatile的解决方案</li><li>允许A2和A3重排序，但不允许其他线程“看到”这个重排序 — 基于类初始化的解决方案</li></ol><h5 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h5><p>把instance声明为volatile型，就可以实现线程安全的延迟初始化。请看下面的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SafeDoubleCheckedLocking &#123;</span><br><span class="line">    private volatile static Instance instance;</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Instance();  // instance为volatile，现在没问题了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当声明对象的引用为volatile后，上面的3行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止。</p><h5 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h5><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化。</p><p>基于这个特性，可以实现另一种线程安全的延迟初始化方案（这个方案被称之为Initialization On Demand Holder idiom）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder &#123;</span><br><span class="line">        public static Instance instance = new Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return InstanceHolder.instance; // 这里将导致InstanceHolder类被初始化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的<strong>初始化锁</strong>LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。</p><p>通过对比基于volatile的双重检查锁定的方案和基于类初始化的方案，我们会发现基于类初始化的方案的实现代码更简洁。<br>但基于volatile的双重检查锁定的方案有一个额外的优势：<br>除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。</p><p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段<br>的开销。<br>在大多数时候，正常的初始化要优于延迟初始化。如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔记内容包含第一章～第三章&lt;/p&gt;&lt;h2 id=&quot;上下文&quot;&gt;&lt;a href=&quot;#上下文&quot; class=&quot;headerlink&quot; title=&quot;上下文&quot;&gt;&lt;/a&gt;上下文&lt;/h2&gt;&lt;p&gt;CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在
      
    
    </summary>
    
      <category term="Java" scheme="https://yidasanqian.github.io/categories/Java/"/>
    
    
      <category term="Concurrency" scheme="https://yidasanqian.github.io/tags/Concurrency/"/>
    
      <category term="并发" scheme="https://yidasanqian.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="volatile" scheme="https://yidasanqian.github.io/tags/volatile/"/>
    
      <category term="synchronized" scheme="https://yidasanqian.github.io/tags/synchronized/"/>
    
      <category term="锁" scheme="https://yidasanqian.github.io/tags/%E9%94%81/"/>
    
      <category term="CAS" scheme="https://yidasanqian.github.io/tags/CAS/"/>
    
      <category term="final" scheme="https://yidasanqian.github.io/tags/final/"/>
    
      <category term="内存语义" scheme="https://yidasanqian.github.io/tags/%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    
      <category term="Java内存模型" scheme="https://yidasanqian.github.io/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="JMM" scheme="https://yidasanqian.github.io/tags/JMM/"/>
    
      <category term="重排序" scheme="https://yidasanqian.github.io/tags/%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
      <category term="happens-before" scheme="https://yidasanqian.github.io/tags/happens-before/"/>
    
      <category term="延迟初始化" scheme="https://yidasanqian.github.io/tags/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot中使用Elasticsearch联合查询</title>
    <link href="https://yidasanqian.github.io/2019/05/29/Spring-boot%E4%B8%AD%E4%BD%BF%E7%94%A8Elasticsearch%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
    <id>https://yidasanqian.github.io/2019/05/29/Spring-boot中使用Elasticsearch联合查询/</id>
    <published>2019-05-29T01:46:55.512Z</published>
    <updated>2019-05-29T01:47:25.381Z</updated>
    
    <content type="html"><![CDATA[<p>加入Elasticsearch依赖：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p></p><p>在application.yml文件配置Elasticsearch：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    rest:</span><br><span class="line">      uris: es节点1,es节点2</span><br><span class="line">      username: 用户名</span><br><span class="line">      password: 密码</span><br></pre></td></tr></table></figure><p>推荐使用这种方式。</p><p>然后就可以使用下面的代码自动装配Elasticsearch的高级版客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RestHighLevelClient restHighLevelClient;</span><br></pre></td></tr></table></figure><p>下面举例如何使用bool联合查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private static final String DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;;</span><br><span class="line"></span><br><span class="line">public List&lt;MsgStateDTO&gt; queryMsgStateLogFromElasticsearch(String appId, String messageId, String receiver) &#123;</span><br><span class="line">    // 使用bool联合查询需要用到BoolQueryBuilder这个构建器，must方法表示完全匹配</span><br><span class="line">    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery()</span><br><span class="line">            .must(QueryBuilders.termQuery(&quot;appId&quot;, appId));</span><br><span class="line">    if (!StringUtils.isEmpty(messageId)) &#123;</span><br><span class="line">        boolQueryBuilder.must(QueryBuilders.termQuery(&quot;messageId&quot;, messageId));</span><br><span class="line">    &#125;</span><br><span class="line">    if (!StringUtils.isEmpty(receiver)) &#123;</span><br><span class="line">        boolQueryBuilder.must(QueryBuilders.termQuery(&quot;receiver&quot;, receiver));</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里使用RangeQueryBuilder进行日期范围查询，‘createTime’是MsgStateDTO类的属性。</span><br><span class="line">    // 这里表示查询到此为止3个月前的数据。</span><br><span class="line">    RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery(&quot;createTime.keyword&quot;)</span><br><span class="line">            .format(DATETIME_FORMAT)</span><br><span class="line">            .timeZone(&quot;+08:00&quot;)</span><br><span class="line">            .from(LocalDateTime.now().minusMonths(3).format(DateTimeFormatter.ofPattern(DATETIME_FORMAT)))</span><br><span class="line">            .to(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATETIME_FORMAT)));</span><br><span class="line">    // 添加过滤条件</span><br><span class="line">    boolQueryBuilder.filter(rangeQueryBuilder);</span><br><span class="line">    // 构建完整的查询语句，SearchSourceBuilder构建表示从第0页开始查询10条，并根据@timestamp字段倒序，然后超时10s</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()</span><br><span class="line">            .query(boolQueryBuilder)</span><br><span class="line">            .size(10)</span><br><span class="line">            .sort(new FieldSortBuilder(&quot;@timestamp&quot;).order(SortOrder.DESC))</span><br><span class="line">            .timeout(new TimeValue(10, TimeUnit.SECONDS));</span><br><span class="line">    SearchRequest searchRequest = new SearchRequest();</span><br><span class="line">    // 指定日志所在的索引</span><br><span class="line">    searchRequest.indices(INDICES_CSP_MSG_STATE);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    log.info(&quot;执行Elasticsearch查询：&#123;&#125;&quot;, searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    List&lt;MsgStateDTO&gt; msgStateDTOList = Collections.emptyList();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行查询</span><br><span class="line">        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        // 结果映射</span><br><span class="line">        SearchHit[] hits = searchResponse.getHits().getHits();</span><br><span class="line">        Set&lt;MsgStateDTO&gt; msgStateDTOSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (SearchHit hit : hits) &#123;</span><br><span class="line">            MsgStateDTO msgStateDTO = $.json.toObject(hit.getSourceAsString(), MsgStateDTO.class);</span><br><span class="line">            msgStateDTOSet.add(msgStateDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        msgStateDTOList = msgStateDTOSet.stream()</span><br><span class="line">                .sorted(Comparator.comparing(MsgStateDTO::getCreateAt).reversed())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(&quot;请求日志服务异常&quot;, e);</span><br><span class="line">        throw new BusinessException(&quot;请求日志服务异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return msgStateDTOList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写得比较详细了，不再进一步说明。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;加入Elasticsearch依赖：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://yidasanqian.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Elasticsearch" scheme="https://yidasanqian.github.io/tags/Elasticsearch/"/>
    
      <category term="BoolQueryBuilder" scheme="https://yidasanqian.github.io/tags/BoolQueryBuilder/"/>
    
      <category term="RangeQueryBuilder" scheme="https://yidasanqian.github.io/tags/RangeQueryBuilder/"/>
    
      <category term="RestHighLevelClient" scheme="https://yidasanqian.github.io/tags/RestHighLevelClient/"/>
    
  </entry>
  
  <entry>
    <title>解决由于设置Mybatis的BatchExecutor批量执行器而导致无法获取自增Id的问题</title>
    <link href="https://yidasanqian.github.io/2019/05/22/%E8%A7%A3%E5%86%B3%E7%94%B1%E4%BA%8E%E8%AE%BE%E7%BD%AEMybatis%E7%9A%84BatchExecutor%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%99%A8%E8%80%8C%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9EId%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yidasanqian.github.io/2019/05/22/解决由于设置Mybatis的BatchExecutor批量执行器而导致无法获取自增Id的问题/</id>
    <published>2019-05-22T05:34:15.903Z</published>
    <updated>2019-05-22T05:35:46.642Z</updated>
    
    <content type="html"><![CDATA[<p>在Mybatis中有三种Executor:</p><ul><li>SimpleExecutor — SIMPLE 就是普通的执行器。</li><li>ReuseExecutor -执行器会重用预处理语句（prepared statements）</li><li>BatchExecutor —它是批量执行器</li></ul><p>这些就是Mybatis的三种执行器。你可以通过配置文件的<code>settings</code>里面的元素<code>defaultExecutorType</code>，配置它，默认是采用SimpleExecutor如果你在Spring运用它，那么你可以这么配置它：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;     </span><br><span class="line">&lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">&lt;!--更新采用批量的executor --&gt;  </span><br><span class="line">&lt;constructor-arg index=&quot;1&quot; value=&quot;BATCH&quot;/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p></p><p>或者在Spring Boot的属性文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.executor-type=BATCH</span><br></pre></td></tr></table></figure><p>如果你在事务中有这么一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Media media = new Media();</span><br><span class="line">media.setTitle(&quot;默认用户头像&quot;);</span><br><span class="line">media.setMediaType(0);</span><br><span class="line">media.setUrl(defaultAvatarUrl);</span><br><span class="line">mediaMapper.insert(media);</span><br><span class="line">logger.info(&quot;mediaId : &quot; + media.getId());</span><br><span class="line">User user = new User();</span><br><span class="line">user.setMedia(media);</span><br><span class="line">userMapper.insert(user);</span><br></pre></td></tr></table></figure><p>那么就会导致<code>Media</code>无法获取插入数据库后的id。</p><p>这是由于设置了<code>executorType=BATCH</code>而导致执行更新Sql时Mybatis没有提交语句到数据库。</p><p>这时有两种解决方法：</p><p>方法1：</p><p>只需要修改Executor为其它两种<code>SIMPLE</code> or <code>REUSE</code>即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;     </span><br><span class="line">&lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">&lt;constructor-arg index=&quot;1&quot; value=&quot;SIMPLE&quot;/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>或者在Spring Boot的属性文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.executor-type=SIMPLE</span><br></pre></td></tr></table></figure><p>方法2:</p><p>在insert方法之后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 刷新批量更新语句缓存，将Sql语句发送到数据库执行</span><br><span class="line">sqlSession.flushStatements();</span><br></pre></td></tr></table></figure><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Mybatis中有三种Executor:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SimpleExecutor — SIMPLE 就是普通的执行器。&lt;/li&gt;&lt;li&gt;ReuseExecutor -执行器会重用预处理语句（prepared statements）&lt;/li&gt;&lt;li&gt;BatchE
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="SimpleExecutor" scheme="https://yidasanqian.github.io/tags/SimpleExecutor/"/>
    
      <category term="ReuseExecutor" scheme="https://yidasanqian.github.io/tags/ReuseExecutor/"/>
    
      <category term="BatchExecutor" scheme="https://yidasanqian.github.io/tags/BatchExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis执行Sql流程源码分析</title>
    <link href="https://yidasanqian.github.io/2019/05/20/Mybatis%E6%89%A7%E8%A1%8CSql%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yidasanqian.github.io/2019/05/20/Mybatis执行Sql流程源码分析/</id>
    <published>2019-05-20T02:55:19.490Z</published>
    <updated>2019-05-20T02:55:40.054Z</updated>
    
    <content type="html"><![CDATA[<p>环境：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-spring-boot-starter: 1.3.4</span><br></pre></td></tr></table></figure><p></p><p>在<code>MybatisAutoConfiguration</code>类中查看Mybatis的<code>SqlSessionFactory</code>接口的实现<code>DefaultSqlSessionFactory</code>是如何注册到Spring容器的。</p><p>由于不是本文重点，这里就不贴源码了，描述下大概流程：</p><p>Mybatis是通过<code>SqlSessionFactoryBean</code>工厂bean的方式获取bean实例的。</p><p>首先通过<code>SqlSessionFactoryBean</code>类的<code>buildSqlSessionFactory</code>方法中调用<code>xmlMapperBuilder.parse()</code>方法<br>将<code>Mapper</code>接口的Class类型作为key，<code>MapperProxyFactory</code>实例作为value注册到<code>MapperRegistry</code>类上。</p><p>然后将<code>MapperRegistry</code>实例设置到<code>Configuration</code>类的<code>mapperRegistry</code>属性上。</p><p>最后调用<code>SqlSessionFactoryBuilder</code>类的<code>build</code>方法完成<code>SqlSessionFactory</code>实例的创建：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">   return new DefaultSqlSessionFactory(config);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>这里看下<code>MapperProxyFactory</code>类的源码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line">  // Mapper接口的Class类型的引用</span><br><span class="line">  private final Class&lt;T&gt; mapperInterface;</span><br><span class="line">  // Mapper接口中定义的方法</span><br><span class="line">  private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123;</span><br><span class="line">    this.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Class&lt;T&gt; getMapperInterface() &#123;</span><br><span class="line">    return mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123;</span><br><span class="line">    return methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到通过调用<code>MapperProxyFactory</code>的<code>newInstance</code>方法完成<code>Mapper</code>接口代理的生成。这里用到了Jdk的动态代理。</p><p>这里说明一点，Mybatis和Spring整合使用<code>SqlSession</code>的实现是<code>SqlSessionTemplate</code>，它是线程安全的由Spring管理的单例bean。</p><p>当调用<code>Mapper</code>接口的方法时，实际上会调用<code>MapperProxy</code>代理的<code>invoke</code>方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      return method.invoke(this, args);</span><br><span class="line">    &#125; else if (isDefaultMethod(method)) &#123;</span><br><span class="line">      return invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存Mapper接口的方法</span><br><span class="line">  final MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  return mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后返回调用<code>MapperMethod</code>类的<code>execute</code>方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">   Object result;</span><br><span class="line">   switch (command.getType()) &#123;</span><br><span class="line">     case INSERT: &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     case UPDATE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     case DELETE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     case SELECT:</span><br><span class="line">       if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">         executeWithResultHandler(sqlSession, args);</span><br><span class="line">         result = null;</span><br><span class="line">       &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">         result = executeForMany(sqlSession, args);</span><br><span class="line">       &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">         result = executeForMap(sqlSession, args);</span><br><span class="line">       &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">         result = executeForCursor(sqlSession, args);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">         result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">       &#125;</span><br><span class="line">       break;</span><br><span class="line">     case FLUSH:</span><br><span class="line">       result = sqlSession.flushStatements();</span><br><span class="line">       break;</span><br><span class="line">     default:</span><br><span class="line">       throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() </span><br><span class="line">         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到这里通过命令模式处理对应的Sql。这里笔者选择执行一条查询命令，那么最终会调用该类的<code>executeForMany</code>方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  // 根据命名规则获取参数映射对象ParamMap</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  // 判断方法上是否有RowBounds参数，如果有则Sql语句加上 offset,limit</span><br><span class="line">  if (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  // issue #510 Collections &amp; arrays support</span><br><span class="line">  if (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    if (method.getReturnType().isArray()) &#123;</span><br><span class="line">      return convertToArray(result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来进入<code>SqlSessionTemplate</code>的<code>selectList</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123;</span><br><span class="line">  return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实是调用的<code>SqlSession</code>的代理来调用实际的<code>selectList</code>方法。<br>查看<code>SqlSessionTemplate</code>类的构造方法的源码有这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">                        new Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">                        new SqlSessionInterceptor());</span><br></pre></td></tr></table></figure><p>可知<code>SqlSessionTemplate</code>持有<code>SqlSession</code>接口的代理，其默认实现是<code>DefaultSqlSession</code>。查看该类的<code>selectList</code>方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // statement是Mapper接口的方法的完全限定名，这里获取对应的映射信息</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Mybatis默认是打开本地缓存的，即每个Session都持有<code>Executor</code>的引用实现<code>CachingExecutor</code>。<br>接下来进入<code>CachingExecutor</code>的<code>query</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">   // 获取绑定的sql对象</span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">   // 创建缓存key</span><br><span class="line">   CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">   return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>进入<code>BaseExecutor</code>的query方法实现，有这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br></pre></td></tr></table></figure><p>继续查看queryFromDatabase方法实现，有这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure><p>由于默认使用Mybatis的ExecutorType是<code>SIMPLE</code>，所以进入<code>SimpleExecutor</code>的doQuery方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">   Statement stmt = null;</span><br><span class="line">   try &#123;</span><br><span class="line">     Configuration configuration = ms.getConfiguration();</span><br><span class="line">     // 1. 根据映射语句执行插件来拦截的方法调用</span><br><span class="line">     StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">     // 2. 预编译语句</span><br><span class="line">     stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">     // 3. 执行查询</span><br><span class="line">     return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     closeStatement(stmt);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第一点，查看实现会返回<code>RoutingStatementHandler</code>实例，由于默认的语句类型是<code>StatementType.PREPARED</code>，<br>所以该类持有<code>PreparedStatementHandler</code>对象的引用。</p><p>第二点，<code>prepareStatement</code>方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">   Statement stmt;</span><br><span class="line">   Connection connection = getConnection(statementLog);</span><br><span class="line">   stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">   // 委托调用PreparedStatementHandler的parameterize方法进行参数设置</span><br><span class="line">   handler.parameterize(stmt);</span><br><span class="line">   return stmt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>PreparedStatementHandler的parameterize方法会调用<code>DefaultParameterHandler</code>的<code>setParameters</code>方法处理参数映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setParameters(PreparedStatement ps) &#123;</span><br><span class="line">  ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  // 获取参数映射列表</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  if (parameterMappings != null) &#123;</span><br><span class="line">    // 遍历参数映射列表</span><br><span class="line">    for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      if (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        // 获取属性名</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params</span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; else if (parameterObject == null) &#123;</span><br><span class="line">          value = null;</span><br><span class="line">        &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          // 根据属性名获取属性值</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取参数类型处理器，假定参数是int/integer类型那么最终typeHandler实例是IntegerTypeHandler</span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        // 获取参数Jdbc类型</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        if (value == null &amp;&amp; jdbcType == null) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 设置参数，如果参数不为空最终会调用IntegerTypeHandler的setNonNullParameter方法设置对应参数值</span><br><span class="line">          typeHandler.setParameter(ps, i + 1, value, jdbcType);</span><br><span class="line">        &#125; catch (TypeException e) &#123;</span><br><span class="line">          throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">          throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三点，委托调用<code>PreparedStatementHandler</code>的query方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  // 执行语句</span><br><span class="line">  ps.execute();</span><br><span class="line">  // 处理结果并返回，唯一实现是DefaultResultSetHandler</span><br><span class="line">  return resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看下结果的映射，结果的类型处理和参数的类型处理都是基于<code>TypeHandler</code>接口的实现，可以看看其抽象类的实现<code>BaseTypeHandler</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public T getResult(ResultSet rs, String columnName) throws SQLException &#123;</span><br><span class="line">  T result;</span><br><span class="line">  try &#123;</span><br><span class="line">    result = getNullableResult(rs, columnName);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new ResultMapException(&quot;Error attempting to get column &apos;&quot; + columnName + &quot;&apos; from result set.  Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">  if (rs.wasNull()) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>getNullableResult</code>方法是抽象方法，将由具体的子类实现。比如有个实体的属性是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private LocalDateTime createAt;</span><br></pre></td></tr></table></figure><p>那么将会使用<code>LocalDateTimeTypeHandler</code>类的实现，也可以指定自己的TypeHandler实现，在<code>&lt;resultMap&gt;</code>标签<br>的子标签<code>&lt;result&gt;</code>自定义typeHandler：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result property=&quot;createAt&quot; column=&quot;create_at&quot; typeHandler=&quot;org.apache.ibatis.type.LocalDateTimeTypeHandler&quot;/&gt;</span><br></pre></td></tr></table></figure><p>到此，Mybatis的调用流程源码分析结束。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="MapperProxy" scheme="https://yidasanqian.github.io/tags/MapperProxy/"/>
    
      <category term="SqlSessionFactory" scheme="https://yidasanqian.github.io/tags/SqlSessionFactory/"/>
    
      <category term="TypeHandler" scheme="https://yidasanqian.github.io/tags/TypeHandler/"/>
    
      <category term="源码分析" scheme="https://yidasanqian.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring WebMVC请求处理流程源码分析</title>
    <link href="https://yidasanqian.github.io/2019/05/07/Spring-WebMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yidasanqian.github.io/2019/05/07/Spring-WebMVC请求处理流程源码分析/</id>
    <published>2019-05-07T07:26:03.807Z</published>
    <updated>2019-05-07T07:31:52.449Z</updated>
    
    <content type="html"><![CDATA[<p>Spring WebMVC 版本：5.1.3.RELEASE</p><p>定义一个controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;dingtalk&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class DingtalkController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DingTalkService dingTalkService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;contact/authscope&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE )</span><br><span class="line">    public Object findContactAuthScope() &#123;</span><br><span class="line">        dingTalkService.getContactAuthScope(dingTalkService.getAccessToken());</span><br><span class="line">        return HttpStatus.OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们请求<code>http://localhost:9000/dingtalk/contact/authscope</code>这个URL时会调用该controller的 findContactAuthScope 方法。<br>那么Spring MVC是怎么实现这个处理流程的呢？</p><p><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/Spring MVC处理流程图.png"></p><p>图源：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veHRkeHMvcC82NjA1NDA5Lmh0bWw=" title="https://www.cnblogs.com/xtdxs/p/6605409.html">SpringMVC流程架构图<i class="fa fa-external-link"></i></span></p><p>我们知道 DispatcherServlet 类是Spring MVC 的入口，<br>每次请求都会调用它的 doService 方法，该方法又将请求委托给 doDispatch 方法处理，我们来看doDispatch方法<br>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">   protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = null;</span><br><span class="line">boolean multipartRequestParsed = false;</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">try &#123;</span><br><span class="line">ModelAndView mv = null;</span><br><span class="line">Exception dispatchException = null;</span><br><span class="line">try &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">// 1. 获取当前请求的HandlerExecutionChain，HandlerExecutionChain持有Handler对象和HandlerInterceptor，</span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line">if (mappedHandler == null) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 获取当前请求的Handler对应的HandlerAdapter</span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">// 如果HandlerMethod支持，处理 last-modified 请求头.</span><br><span class="line">String method = request.getMethod();</span><br><span class="line">boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">// 请求资源未改变则中断处理直接返回</span><br><span class="line">if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 通过HandlerAdapter调用具体的HandlerMethod来处理请求，最后返回ModelAndView</span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">// 视图解析和显示</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1点getHandler方法的实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   @Nullable</span><br><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">if (this.handlerMappings != null) &#123;</span><br><span class="line">for (HandlerMapping mapping : this.handlerMappings) &#123;</span><br><span class="line">    // 获取当前请求的拦截器列表和Handler对象</span><br><span class="line">HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">// 这里的mapping实例是RequestMappingHandlerMapping，通过 getHandler 方法获取到的hanlder不为空</span><br><span class="line">if (handler != null) &#123;</span><br><span class="line">return handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>RequestMappingHandlerMapping 类用于从@Controller注解所在的类的@RequestMapping注解上<br>构建（RequestMappingInfo）请求映射信息实例。</p><p>可以看到是通过遍历HandlerMapping列表，然后调用每个HandlerMapping接口的getHandler方法，进入<br>实现该接口的抽象类 AbstractHandlerMapping 重写的getHandler方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">@Nullable</span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">    // 查询当前请求的HandlerMethod</span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line">// 当前请求的Handler如果为空则获取默认的HandlerMethod</span><br><span class="line">if (handler == null) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line">if (handler == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">// 如果handler是bean name字符串则获取对应的bean实例</span><br><span class="line">if (handler instanceof String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">       // 添加HandlerMethod和HandlerInterceptor拦截器到HandlerExecutionChain中，对应handler和interceptorList成员变量</span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">       // 如果请求头包含Origin则进行跨域配置</span><br><span class="line">if (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">CorsConfiguration globalConfig = this.corsConfigurationSource.getCorsConfiguration(request);</span><br><span class="line">CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到AbstractHandlerMethodMapping的getHandlerInternal方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">    // 查询到请求uri为 /dingtalk/contact/authscope</span><br><span class="line">String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">this.mappingRegistry.acquireReadLock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 根据查询到的路径查询当前请求对应的HandlerMethod</span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">this.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就查到请求的uri对应的是findContactAuthScope方法。</p><p>下一步执行第2点，获取HandlerMethod对应的HandlerAdapter，查看getHandlerAdapter方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;</span><br><span class="line">if (this.handlerAdapters != null) &#123;</span><br><span class="line">for (HandlerAdapter adapter : this.handlerAdapters) &#123;</span><br><span class="line">    // 这里返回的是 RequestMappingHandlerAdapter 实例，继承AbstractHandlerMethodAdapter </span><br><span class="line">    // 用于支持@RequestMapping注解的类和方法</span><br><span class="line">if (adapter.supports(handler)) &#123;</span><br><span class="line">return adapter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步执行第3点，调用 AbstractHandlerMethodAdapter的handle方法，最终会调用子类的handleInternal方法，<br>该方法位于RequestMappingHandlerAdapter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">protected ModelAndView handleInternal(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ModelAndView mav;</span><br><span class="line">// 检查给定的请求是否支持（request method）方法和所需（session）会话(如果有的话)</span><br><span class="line">checkRequest(request);</span><br><span class="line"></span><br><span class="line">// 如果需要会话同步则运行 invokeHandlerMethod 方法在同步代码块中</span><br><span class="line">if (this.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(false);</span><br><span class="line">if (session != null) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">synchronized (mutex) &#123;</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 没有可用的 HttpSession  -&gt; 不需要互斥锁</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 根本不需要会话同步 ...</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">return mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invokeHandlerMethod方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   @Nullable</span><br><span class="line">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ServletWebRequest webRequest = new ServletWebRequest(request, response);</span><br><span class="line">try &#123;</span><br><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">if (this.argumentResolvers != null) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line">if (this.returnValueHandlers != null) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">ModelAndViewContainer mavContainer = new ModelAndViewContainer();</span><br><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(this.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(this.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">if (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line">LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line">           // 调用controller的目标方法</span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">           // 返回ModelAndView</span><br><span class="line">return getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">webRequest.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在此方法中调用了<code>invokeAndHandle</code>方法，实现反射调用目标方法并通过 HandlerMethodReturnValueHandler 接口的实现类处理返回结果值，<br>然后会调用实现了ResponseBodyAdvice 接口的类的beforeBodyWrite方法处理返回值，<br>最后通过实现了GenericHttpMessageConverter 接口的类将响应body写入输出流信息中。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring WebMVC 版本：5.1.3.RELEASE&lt;/p&gt;&lt;p&gt;定义一个controller&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="Spring" scheme="https://yidasanqian.github.io/categories/Spring/"/>
    
    
      <category term="DispatcherServlet" scheme="https://yidasanqian.github.io/tags/DispatcherServlet/"/>
    
      <category term="HandlerMapping" scheme="https://yidasanqian.github.io/tags/HandlerMapping/"/>
    
      <category term="HandlerAdapter" scheme="https://yidasanqian.github.io/tags/HandlerAdapter/"/>
    
  </entry>
  
  <entry>
    <title>解决SQLFeatureNotSupportedException异常</title>
    <link href="https://yidasanqian.github.io/2019/04/22/%E8%A7%A3%E5%86%B3SQLFeatureNotSupportedException%E5%BC%82%E5%B8%B8/"/>
    <id>https://yidasanqian.github.io/2019/04/22/解决SQLFeatureNotSupportedException异常/</id>
    <published>2019-04-22T06:40:23.791Z</published>
    <updated>2019-06-18T02:27:11.048Z</updated>
    
    <content type="html"><![CDATA[<p>环境：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdk：1.8</span><br><span class="line">mybatis-spring-boot-starter：2.0.1</span><br><span class="line">druid-spring-boot-starter: 1.1.14</span><br><span class="line">mysql-connector-java: 5.1.47</span><br><span class="line">spring-boot-starter-parent: 2.1.4.RELEASE</span><br></pre></td></tr></table></figure><p></p><p>使用Mybatis查询时出现以下异常：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.InvalidDataAccessApiUsageException: Error attempting to get column &apos;create_at&apos; from result set.  Cause: java.sql.SQLFeatureNotSupportedException</span><br><span class="line">; null; nested exception is java.sql.SQLFeatureNotSupportedException</span><br><span class="line"></span><br><span class="line">at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:96)</span><br><span class="line">at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72)</span><br><span class="line">at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81)</span><br><span class="line">at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:73)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446)</span><br><span class="line">at com.sun.proxy.$Proxy68.selectList(Unknown Source)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230)</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:147)</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:80)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:58)</span><br><span class="line">at com.sun.proxy.$Proxy69.queryAllByLimit(Unknown Source)</span><br><span class="line">at io.github.yidasanqian.mybatisdemo.service.impl.RoleServiceImpl.queryAllByLimit(RoleServiceImpl.java:44)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)</span><br><span class="line">at com.sun.proxy.$Proxy72.queryAllByLimit(Unknown Source)</span><br><span class="line">at io.github.yidasanqian.mybatisdemo.MybatisDemoApplicationTests.testRoleQuery(MybatisDemoApplicationTests.java:45)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)</span><br><span class="line">at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)</span><br><span class="line">at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)</span><br><span class="line">at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)</span><br><span class="line">at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</span><br><span class="line">at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</span><br><span class="line">at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</span><br><span class="line">at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</span><br><span class="line">at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)</span><br><span class="line">at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:137)</span><br><span class="line">at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)</span><br><span class="line">at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)</span><br><span class="line">Caused by: java.sql.SQLFeatureNotSupportedException</span><br><span class="line">at com.alibaba.druid.pool.DruidPooledResultSet.getObject(DruidPooledResultSet.java:1771)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.ibatis.logging.jdbc.ResultSetLogger.invoke(ResultSetLogger.java:69)</span><br><span class="line">at com.sun.proxy.$Proxy94.getObject(Unknown Source)</span><br><span class="line">at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:38)</span><br><span class="line">at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:28)</span><br><span class="line">at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:81)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getPropertyMappingValue(DefaultResultSetHandler.java:472)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyPropertyMappings(DefaultResultSetHandler.java:441)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:404)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForSimpleResultMap(DefaultResultSetHandler.java:354)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:301)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:194)</span><br><span class="line">at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:65)</span><br><span class="line">at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79)</span><br><span class="line">at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)</span><br><span class="line">at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)</span><br><span class="line">at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:147)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433)</span><br><span class="line">... 51 more</span><br></pre></td></tr></table></figure><p></p><p>Mapper.xml:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;io.github.yidasanqian.mybatisdemo.entity.Role&quot; id=&quot;Role_ResultMap&quot;&gt;</span><br><span class="line">    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;createAt&quot; column=&quot;create_at&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;updateAt&quot; column=&quot;update_at&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p></p><p>Role.java<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Role implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -50780509322421020L;</span><br><span class="line">    </span><br><span class="line">    private Integer id;    </span><br><span class="line">    private String name;    </span><br><span class="line">    private LocalDateTime createAt;    </span><br><span class="line">    private LocalDateTime updateAt;    </span><br><span class="line">    // ignored getter &amp; setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>原因是<code>Druid</code>不支持JDBC4.1及以上版本导致的，可以将<code>mybatis-spring-boot-starter</code><br>版本降为1.3.4即可解决。</p><p>Druid 1.1.18 版本已解决此问题，详情看此issue：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvZHJ1aWQvaXNzdWVzLzMxOTQ=" title="https://github.com/alibaba/druid/issues/3194">3194<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="Druid" scheme="https://yidasanqian.github.io/tags/Druid/"/>
    
      <category term="LocalDateTimeTypeHandler" scheme="https://yidasanqian.github.io/tags/LocalDateTimeTypeHandler/"/>
    
  </entry>
  
  <entry>
    <title>教你如何让Mac定时自动开关黑暗模式</title>
    <link href="https://yidasanqian.github.io/2019/04/17/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E8%AE%A9Mac%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yidasanqian.github.io/2019/04/17/教你如何让Mac定时自动开关黑暗模式/</id>
    <published>2019-04-17T06:53:40.694Z</published>
    <updated>2019-04-17T07:21:31.847Z</updated>
    
    <content type="html"><![CDATA[<p>首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;System Events&quot;</span><br><span class="line">tell appearance preferences</span><br><span class="line">set dark mode to not dark mode</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p></p><p>然后使用<code>crontab -e</code>新建定时任务,英文输入法下输入命令<code>i</code>进入编辑模式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 22 * * * osascript ~/ChangeDarkMode.applescript</span><br><span class="line">12 9 * * * osascript ~/ChangeDarkMode.applescript</span><br></pre></td></tr></table></figure><p></p><p>第一行表示每天22:00 开启黑暗模式。第二行表示每天9:12，关闭黑暗模式。</p><p>最后按<code>esc</code>退出编辑模式，并输入命令<code>:wq</code>保存退出。</p><blockquote><p>输入命令<code>crontab -l</code>可查看任务是否新建成功。</p></blockquote><p><strong>需要注意的是如果Mac处于睡眠状态的话定时任务是不起作用的，此时需要手动开启或关闭黑暗模式！</strong></p><p>如果你的Mac安装了Alfred，那么可以使用<a href="/asserts/切换外观模式.alfredworkflow">切换外观模式</a>工作流脚本来手动切换黑暗模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="Mac" scheme="https://yidasanqian.github.io/categories/Mac/"/>
    
    
      <category term="DarkMode" scheme="https://yidasanqian.github.io/tags/DarkMode/"/>
    
      <category term="AppleScript" scheme="https://yidasanqian.github.io/tags/AppleScript/"/>
    
      <category term="crontab" scheme="https://yidasanqian.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactory和FactoryBean接口的区别</title>
    <link href="https://yidasanqian.github.io/2019/04/11/BeanFactory%E5%92%8CFactoryBean%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://yidasanqian.github.io/2019/04/11/BeanFactory和FactoryBean接口的区别/</id>
    <published>2019-04-11T06:38:56.672Z</published>
    <updated>2019-04-11T06:40:37.138Z</updated>
    
    <content type="html"><![CDATA[<p>Spring版本：5.1.3.RELEASE</p><p><code>BeanFactory</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">Object getBean(String name) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line">Object getBean(String name, Object... args) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;</span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);</span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);</span><br><span class="line">boolean containsBean(String name);</span><br><span class="line">boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class="line">Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name);</span><br></pre></td></tr></table></figure><blockquote><p>是简单工厂模式的应用，根据传入的beanName实例化相应的实例。</p></blockquote><p><strong>JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）</strong>：</p><p>用于访问Spring bean容器的根接口。 这是bean容器的基本客户端视图; 其他接口（如ListableBeanFactory和org.springframework.beans.factory.config.ConfigurableBeanFactory）可用于特定目的。</p><p>该接口被一些持有bean定义的对象实现，每个bean定义由一个字符串名称唯一标识。<br>根据bean定义，工厂将返回包含对象的独立实例（Prototype设计模式）或单个共享实例（Singleton设计模式的高级替代，其中实例是工厂范围中的单例）。</p><p>将返回哪种类型的实例取决于bean工厂配置：API是相同的。<br>从Spring 2.0开始，根据具体的应用程序上下文（例如Web环境中的“request”和“session”范围），可以使用更多的scope（范围）。</p><p>这种方法的重点是BeanFactory是应用组件的注册中心和集中的配置中心（例如，不再需要单个对象去读取属性文件）。<br>有关此方法的优点的讨论，请参见”Expert One-on-One J2EE Design and Development”的第4章和第11章。</p><p>请注意，依靠依赖注入（“push”配置）通过setter或构造函数来配置应用对象通常更好,而不是像BeanFactory查找一样的使用“pull”配置的任意方式。Spring的依赖注入功能是使用这个BeanFactory接口及其子接口实现的。</p><p>通常，BeanFactory将加载存储在配置源（例如XML文档）中的bean定义，并使用org.springframework.beans包来配置bean。尽管如此，一种简单地实现是直接在Java代码中返回Java对象。如何存储定义没有限制：LDAP，RDBMS，XML，属性文件等。鼓励实现支持bean之间的引用（依赖注入）。</p><p>与ListableBeanFactory中的方法相反，如果这是HierarchicalBeanFactory，则此接口中的所有操作也将检查父工厂。如果在此工厂实例中找不到bean，则会询问直接父工厂（从父类bean工厂中获取）。此工厂实例中的Bean应该在任何父工厂中覆盖同名的Bean。</p><p>Bean工厂实现应尽可能支持标准bean生命周期接口。 完整的初始化方法及其标准顺序是：</p><ol><li>BeanNameAware 接口的 setBeanName 方法</li><li>BeanClassLoaderAware 接口的 setBeanClassLoader 方法</li><li>BeanFactoryAware 接口的 setBeanFactory 方法</li><li>EnvironmentAware 接口的 setEnvironment 方法</li><li>EmbeddedValueResolverAware 接口的 setEmbeddedValueResolver 方法</li><li>ResourceLoaderAware 接口的 setResourceLoader 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ApplicationEventPublisherAware 接口的 setApplicationEventPublisher 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>MessageSourceAware 接口的 setMessageSource 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ApplicationContextAware 接口的 setApplicationContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ServletContextAware 接口的 setServletContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>所有实现了BeanPostProcessor接口的类的 postProcessBeforeInitialization 方法</li><li>InitializingBean 接口的 afterPropertiesSet 方法</li><li>自定义的init方法</li><li>所有实现了BeanPostProcessor接口的类的 postProcessAfterInitialization 方法</li></ol><p>关闭Bean工厂时，应用以下生命周期方法:</p><ol><li>所有实现了DestructionAwareBeanPostProcessor接口的类的 postProcessBeforeDestruction 方法</li><li>DisposableBean 接口的 destroy 方法</li><li>自定义的destroy 方法</li></ol><p><strong>Spring Bean生命周期图：</strong></p><center><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/spring-bean-lifecycle.png?x-oss-process=style/base-rule" width="55%" height="30%"></center><blockquote><p>Spring 4.3.17.RELEASE 源码的JavaDoc文档写的也是以上流程。跟其它网上的文章写的流程有出入，应该以官方文档为准。</p></blockquote><p><code>FactoryBean</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T getObject() throws Exception;</span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line">default boolean isSingleton() &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>是工厂方法模式的应用，由子类实现相应的实例。</p></blockquote><p><strong>JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）</strong>：</p><p>接口被BeanFactory中使用的对象所实现，这些对象本身就是单个对象的工厂。如果bean实现了这个接口，它将被用作暴露此对象的工厂，而不是直接将自己作为bean实例给暴露出来。</p><p><strong>注意：实现此接口的bean不能用作普通bean。</strong></p><p>FactoryBean是被定义成bean的形式，但是bean对象的引用（getObject()方法获得）始终是由它创建的。</p><p>FactoryBeans可以支持单例和原型，可以根据需要懒惰地创建对象，也可以在启动时急切地创建对象。<br>SmartFactoryBean接口允许公开更细粒度的行为元数据。</p><p>该接口在框架内部大量使用，例如用于AOP的 org.springframework.aop.framework.ProxyFactoryBean类 或 org.springframework.jndi.JndiObjectFactoryBean类。<br>它也可以用于定制组件;但是，这仅适用于基础架构代码。</p><p><strong>FactoryBean是一个programatic contract (编程合约)。实现不应该依赖annotation-driven (注解驱动)的注入或其他反射设施。</strong></p><p>getObjectType()和getObject()方法的调用可能在引导过程的早期发生，甚至在所有的（post-processor）后置处理器设置之前。<br>如果您需要访问其他bean，请实现 BeanFactoryAware 并以编程方式获取它们。</p><p>最后，FactoryBean对象参与包含BeanFactory的bean创建的同步。<br>除了FactoryBean本身（或类似）中的延迟初始化之外，通常不需要内部同步。</p><p>下面从源码层面深入分析二者区别：</p><p>查看 BeanFactory接口的抽象类 AbstractBeanFactory的getObjectForBeanInstance方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   protected Object getObjectForBeanInstance(</span><br><span class="line">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">// bean的name如果以&amp;开头，则是FactoryBean实例</span><br><span class="line">if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">// 验证是否是FactoryBean对象，不是则抛出异常</span><br><span class="line">if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回.</span><br><span class="line">if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = null;</span><br><span class="line">if (mbd == null) &#123;</span><br><span class="line">    // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">// beanInstance强转为FactoryBean</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">// 如果是单例，则缓存从FactoryBean获取的对象</span><br><span class="line">if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">// 最终调用FactoryBean实例的getObject方法获取bean实例</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getObjectFromFactoryBean方法实现中会调用doGetObjectFromFactoryBean方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)</span><br><span class="line">throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">Object object;</span><br><span class="line">try &#123;</span><br><span class="line">if (System.getSecurityManager() != null) &#123;</span><br><span class="line">AccessControlContext acc = getAccessControlContext();</span><br><span class="line">try &#123;</span><br><span class="line">    // 调用FactoryBean的getObject方法来返回实例</span><br><span class="line">object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // 调用FactoryBean的getObject方法来返回实例</span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>实现FactoryBean的类,在初始化放入容器后,通过BeanFactory的getBean方法调用时,会调用FactoryBean的getObject方法返回对应的bean实例对象,而不是像普通的bean一样直接返回bean实例.</p><p>BeanFactory的常量<code>&amp;</code>的作用是在获取bean的时候直接返回FactoryBean的bean实例,而不是调用的getObject方法返回对应的bean实例.</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring版本：5.1.3.RELEASE&lt;/p&gt;&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;接口：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Spring" scheme="https://yidasanqian.github.io/categories/Spring/"/>
    
    
      <category term="BeanFactory" scheme="https://yidasanqian.github.io/tags/BeanFactory/"/>
    
      <category term="FactoryBean" scheme="https://yidasanqian.github.io/tags/FactoryBean/"/>
    
      <category term="Bean生命周期" scheme="https://yidasanqian.github.io/tags/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Skipping MapperFactoryBean with name ‘xxxMapper&#39; mapperInterface</title>
    <link href="https://yidasanqian.github.io/2019/04/10/Skipping-MapperFactoryBean-with-name-%E2%80%98xxxMapper-mapperInterface/"/>
    <id>https://yidasanqian.github.io/2019/04/10/Skipping-MapperFactoryBean-with-name-‘xxxMapper-mapperInterface/</id>
    <published>2019-04-10T06:42:17.463Z</published>
    <updated>2019-04-10T06:44:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>解决Spring Boot应用整合Mybatis启动输出警告日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] o.m.s.mapper.ClassPathMapperScanner - Skipping MapperFactoryBean with name &apos;channelMapper&apos; and &apos;io.github.yidasanqian.dao.ChannelMapper&apos; mapperInterface. Bean already defined with the same name!</span><br></pre></td></tr></table></figure><p>这是由于mybatis-spring-boot-starter 依赖的自动配置导致的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p></p><p>只需要在应用启动类加上注解 @MapperScan 即可，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&#123;&quot;io.github.yidasanqian.dao&quot;&#125;)</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">public class ChannelApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ChannelApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是要指定扫描的mapper接口包路径，上面表示扫描包为io.github.yidasanqian.dao下的所有mapper接口定义。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决Spring Boot应用整合Mybatis启动输出警告日志：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="MapperFactoryBean" scheme="https://yidasanqian.github.io/tags/MapperFactoryBean/"/>
    
      <category term="MapperScan" scheme="https://yidasanqian.github.io/tags/MapperScan/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot启动流程源码分析</title>
    <link href="https://yidasanqian.github.io/2019/04/09/Spring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yidasanqian.github.io/2019/04/09/Spring-Boot启动流程源码分析/</id>
    <published>2019-04-09T01:47:30.663Z</published>
    <updated>2019-04-09T01:48:03.053Z</updated>
    
    <content type="html"><![CDATA[<p>版本：2.1.1.RELEASE</p><p>使用main方法启动Spring Boot应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(DingtalkApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入SpringApplication类的run方法最终实现位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    // 1. 启动计时</span><br><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">// 2. 回调接口SpringBootExceptionReporter用于支持自定义spring应用程序启动错误的报告</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">// 3. 配置启用Java headless模式 </span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">// 4. 获取Spring应用run方法的监听器集合并启动所有的监听器</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">    // 5. 提供对用于运行SpringApplication的参数的访问</span><br><span class="line">ApplicationArguments applicationArguments = new DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">// 6. 创建和配置环境</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">    // 7. 配置忽略BeanInfo类的加载</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">// 8. 打印Banner</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">// 9. 创建ApplicationContext</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">// 10. 获取异常报告实例列表</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">// 11. 准备应用上下文</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">// 12. 刷新底层的ApplicationContext</span><br><span class="line">refreshContext(context);</span><br><span class="line">// 13. protected方法，应用上下文刷新后，子类可实现此方法用于后续的操作</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">// 14. 打印应用启动信息</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">// 15. 启动实现了CommandLineRunner 和 ApplicationRunner 接口的类的run方法 </span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    // 16. 在run 方法结束之前立即调用，发布事件，应用程序已准备好接受服务请求</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run方法源码上注释了大概流程，接下来继续深入重点流程的源码。</p><p><strong>流程4，获取Spring应用run方法的监听器集合并启动所有的监听器:</strong></p><p>getRunListeners(String[] args) 方法源码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>返回SpringApplicationRunListeners 实例，直接看构造方法的第二个参数的getSpringFactoriesInstances方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">// 1. 获取类加载器</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">// 2. 获取指定类型的工厂实现类的完全限定类名集合</span><br><span class="line">Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">// 3. 根据传入的完全限定类名集合创建对应工厂实例</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">classLoader, args, names);</span><br><span class="line">    // 4. 根据工厂实例上的@Order注解指定的顺序排序</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法第一个参数这里传入的是SpringApplicationRunListener 接口，会获取该接口所在类加载器下的“META-INF/spring.factories”属性文件<br>设置的接口实现org.springframework.boot.context.event.EventPublishingRunListener，然后调用该类的构造方法实例化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">this.application = application;</span><br><span class="line">this.args = args;</span><br><span class="line">this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的主要作用是作为应用启动过程的事件发布监听器，可以看到构造方法中实例化了一个简单的应用事件多播器SimpleApplicationEventMulticaster 并遍历添加应用启动事件监听器。</p><p>流程4最后调用listeners.starting() 启动监听器，实现源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void starting() &#123;</span><br><span class="line">this.initialMulticaster.multicastEvent(</span><br><span class="line">new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法多播一个ApplicationStartingEvent实例（应用启动事件），事件源是SpringApplication本身。<br>接下来就是解析事件类型并调用对应的事件监听器了，感兴趣的可以自己深入。深入之前需要对Spring事件机制有所了解，<br>推荐此文<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kY2JlOGYwYWZiZGI=" title="https://www.jianshu.com/p/dcbe8f0afbdb">Spring事件机制<i class="fa fa-external-link"></i></span>。</p><p><strong>流程6. 创建和配置环境：</strong></p><p>prepareEnvironment(listeners, applicationArguments)方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   private ConfigurableEnvironment prepareEnvironment(</span><br><span class="line">SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments) &#123;</span><br><span class="line">// 创建环境</span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">// 配置环境</span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">// 发布环境准备事件</span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">// 绑定环境到此应用</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">// 判断是否需要转换环境</span><br><span class="line">if (!this.isCustomEnvironment) &#123;</span><br><span class="line">environment = new EnvironmentConverter(getClassLoader())</span><br><span class="line">.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">// 附加ConfigurationPropertySource支持到指定环境</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中，getOrCreateEnvironment() 方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">if (this.environment != null) &#123;</span><br><span class="line">return this.environment;</span><br><span class="line">&#125;</span><br><span class="line">// 根据ClassPath存在的类推断应用运行环境，以下都是web环境</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">return new StandardServletEnvironment();</span><br><span class="line">case REACTIVE:</span><br><span class="line">return new StandardReactiveWebEnvironment();</span><br><span class="line">default:</span><br><span class="line">return new StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程9. 创建ApplicationContext：</strong></p><p>createApplicationContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">if (contextClass == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">    // 1. 初始化并返回org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext Class对象</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 忽略异常捕获代码</span><br><span class="line">&#125;</span><br><span class="line">// 2. 调用AnnotationConfigServletWebServerApplicationContext对象的默认构造方法实例化</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>流程11. 准备应用上下文：</strong></p><p>prepareContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   private void prepareContext(ConfigurableApplicationContext context,</span><br><span class="line">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">// 1. 设置环境</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">// 2. 在ApplicationContext中应用任何相关的后置处理,这里为context对象的BeanFactory实例DefaultListableBeanFactory添加转换服务</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">// 3. 在context刷新之前应用实现了ApplicationContextInitializer回调接口的实例进行context上下文对象的初始化</span><br><span class="line">applyInitializers(context);</span><br><span class="line">// 4. 发布context初始化事件</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">// 5. 打印应用版本信息和激活的配置文件信息active profile</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == null);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line">// 6. 添加名称为springApplicationArguments，springBootBanner的单例bean</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">if (printedBanner != null) &#123;</span><br><span class="line">beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">// 7. 加载源（即main方法所在的类对象）不可变的集合对象并注册其bean到应用上下文</span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">load(context, sources.toArray(new Object[0]));</span><br><span class="line">// 8. 发布应用准备事件</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>应用上下文对象准备好了，接下来就进行刷新上下文操作。</p><p><strong>12. 刷新底层的ApplicationContext：</strong></p><p>refreshContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">refresh(context);</span><br><span class="line">if (this.registerShutdownHook) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    // 向JVM运行时注册一个关机钩子，在JVM关闭时同时关闭这个上下文。</span><br><span class="line">context.registerShutdownHook();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>进入到ServletWebServerApplicationContext类的refresh(context)方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public final void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">super.refresh();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是直接调用的父类AbstractApplicationContext的refresh方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">// 1. 准备好刷新上下文</span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line">// 2. 告诉子类刷新内部bean工厂</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">// 3. 准备bean工厂以用于此上下文中</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 4. 允许在特定的ApplicationContext实现中注册特殊的bean后置处理器</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">// 5. 实例化并调用所有已注册的BeanFactoryPostProcessor bean</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 6. 实例化并调用所有已注册的BeanPostProcessor bean</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 7. 初始化MessageSource用于当前上下文，提供参数化和i18n的支持</span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line">// 8. 初始化事件多路广播用于当前上下文，默认使用SimpleApplicationEventMulticaster单例bean</span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">// 9. 在特定上下文子类中初始化其他特殊bean。</span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line">// 10. 检查监听器bean并注册它们</span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">// 11. 实例化剩余所有非懒加载的单例bean</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">// 12. 最后一步: 发布相应的事件</span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">......</span><br><span class="line">            // 销毁所有创建的单例来避免悬空资源</span><br><span class="line">destroyBeans();</span><br><span class="line">// 重置 &apos;active&apos; 标识.</span><br><span class="line">cancelRefresh(ex);</span><br><span class="line">// 抛出异常给调用者</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">// 重置Spring的公共反射元数据缓存</span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一点主要做了以下操作：</p><ul><li>清除本地元数据缓存(如果有的话)，删除所有缓存的类元数据。</li><li>设置其启动日期和活动标志以及执行任何属性源的初始化。</li></ul><p>第二点主要做了以下操作：</p><ul><li>将成员变量 refreshed 设为 true。</li><li>为 DefaultListableBeanFactory 指定一个用于序列化的id。</li></ul><p>第三点主要做了以下操作：</p><ul><li>配置工厂的标准上下文特征，例如上下文的类加载器和后置处理程序。</li><li>所有bean定义都已加载，但还没有实例化bean。</li></ul><p>第四点主要做了以下操作：</p><ul><li>注册特定应用上下文的后置处理器bean</li><li>扫描basePackage指定的包路径</li><li>注册被注解的类，例如@Configuration</li></ul><p>第五点主要做了以下操作：</p><ul><li>实例化并调用所有已注册的BeanFactoryPostProcessor bean，如果给定显式顺序，则遵循显式顺序</li><li>分别调用实现了BeanFactoryPostProcessor接口的bean。</li></ul><p>第六点主要做了以下操作：</p><ul><li>实例化并调用所有已注册的BeanPostProcessor bean，如果给定显式顺序，则遵循显式顺序</li><li>分别调用实现了BeanPostProcessor接口的bean。</li></ul><p>第九点主要做了以下操作：</p><ul><li>默认创建TomcatWebServer</li><li>初始化WebApplicationContext和SerlvetContext参数</li></ul><p>第十一点完成BeanFactory的初始化并实例化剩余的单例bean：</p><p>finishBeanFactoryInitialization方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">// 初始化用于此上下文的转换服务</span><br><span class="line">if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果没有内嵌value解析器Bean则注册一个(例如 PropertyPlaceholderConfigurer bean)，主要用于解析$&#123;&#125;占位符.</span><br><span class="line">if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尽早地初始化LoadTimeWeaverAware bean以允许尽早地注册其变换器</span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止正用于类型匹配的临时类加载器</span><br><span class="line">beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">// 缓存所有bean定义的元数据，不接受后面的改变</span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">// 实例化所有剩余的（非懒加载）单例bean</span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中重点看最后一步preInstantiateSingletons方法的实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">// 迭代一个beanDefinitionNames的副本以允许init方法，这些方法又轮流注册新的bean定义。</span><br><span class="line">// 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。</span><br><span class="line">List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">// 触发所有非懒加载单例bean的初始化...</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">// 如果不是抽象的bean并且是非懒加载的单例bean，则进行</span><br><span class="line">if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">    // 判断是否是FactoryBean，如果是则进一步判断是否需要尽早的初始化bean，否则直接初始化bean</span><br><span class="line">if (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">if (bean instanceof FactoryBean) &#123;</span><br><span class="line">final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">boolean isEagerInit;</span><br><span class="line">if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line">if (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 触发所有可用单例bean的afterSingletonsInstantiated方法回调...</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line">if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">if (System.getSecurityManager() != null) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">return null;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来看getBean(beanName)方法的底层实现，是直接调用doGetBean方法，返回指定bean的实例，该实例可以是共享的或独立的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">       // 1. 返回bean名称，必要时删除工厂前缀，并将别名解析为规范名称。</span><br><span class="line">final String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line">// 2. 急切地检查单例缓存以手动地注册单例</span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line">if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">    // 3. 判断该当前bean是否在创建中</span><br><span class="line">if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</span><br><span class="line">&quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">logger.trace(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 4. 获取给定bean实例的对象，如果是FactoryBean，则为bean实例本身或其创建的对象。</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">    // 其它情况暂不做深入研究，感兴趣的读者可以自行阅读AbstractBeanFactory#doGetBean方法源码</span><br><span class="line">    ......</span><br><span class="line">       &#125;</span><br><span class="line">return (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看第二点getSingleton方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   @Nullable</span><br><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">// 如果从singletonObjects单例bean缓存中获取key为beanName的单例bean为空并且该单例bean</span><br><span class="line">// 当前在创建中（在整个工厂内）则从早期已实例化的单例bean缓存earlySingletonObjects中</span><br><span class="line">// 检查beanName的单例对象，如果为空则进一步从singletonFactories单例工厂缓存中获取beanName为key</span><br><span class="line">// 的BeanFactory，如果BeanFactory不为空则获取到其管理的单例bean实例并将其缓存</span><br><span class="line">// 到earlySingletonObjects对象上，最后从singletonFactories缓存中移除管理该beanName</span><br><span class="line">// 实例的BeanFactory对象（解决循环引用）</span><br><span class="line">if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">synchronized (this.singletonObjects) &#123;</span><br><span class="line">singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">if (singletonFactory != null) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">this.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要对象说明：</p><ul><li>singletonObjects：单例bean对象的缓存，ConcurrentHashMap-&gt;{beanName:beanInstance}</li><li>earlySingletonObjects: 早期的单例bean对象的缓存，HashMap-&gt;{beanName:beanInstance}</li><li>singletonFactories：单例BeanFactory的缓存，HashMap-&gt;{beanName:beanFactory}, beanFactory-&gt;beanInstance</li></ul><p>查看第四点getObjectForBeanInstance方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   protected Object getObjectForBeanInstance(</span><br><span class="line">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">// bean的name如果以&amp;开头，则是FactoryBean实例</span><br><span class="line">if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">// 验证是否是FactoryBean对象，不是则抛出异常</span><br><span class="line">if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回.</span><br><span class="line">if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = null;</span><br><span class="line">if (mbd == null) &#123;</span><br><span class="line">    // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">// beanInstance强转为FactoryBean</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">// 如果是单例，则缓存从FactoryBean获取的对象</span><br><span class="line">if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">// 最终调用FactoryBean实例的getObject方法获取bean实例</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到refresh方法的第十二点，最后完成上下文的刷新操作，调用LifecycleProcessor的onRefresh方法并且发布最终的ContextRefreshedEvent事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   protected void finishRefresh() &#123;</span><br><span class="line">// 清除此资源加载器中的所有资源缓存。</span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line">// 初始化此上下文的生命周期处理器DefaultLifecycleProcessor。</span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">// 调用DefaultLifecycleProcessor的onRefresh方法</span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">// 发布最终的ContextRefreshedEvent事件</span><br><span class="line">publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line"></span><br><span class="line">// 如果激活则参与到LiveBeansView MBean中</span><br><span class="line">LiveBeansView.registerApplicationContext(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类finishRefresh方法最后启动相应的WebServer并发布事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">protected void finishRefresh() &#123;</span><br><span class="line">super.finishRefresh();</span><br><span class="line">WebServer webServer = startWebServer();</span><br><span class="line">if (webServer != null) &#123;</span><br><span class="line">publishEvent(new ServletWebServerInitializedEvent(webServer, this));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<strong>Spring Boot启动流程源码分析</strong>的完整内容，如果有问题欢迎提出！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版本：2.1.1.RELEASE&lt;/p&gt;&lt;p&gt;使用main方法启动Spring Boot应用：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://yidasanqian.github.io/categories/Spring-Boot/"/>
    
    
      <category term="源码分析" scheme="https://yidasanqian.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="doGetBean" scheme="https://yidasanqian.github.io/tags/doGetBean/"/>
    
      <category term="refreshContext" scheme="https://yidasanqian.github.io/tags/refreshContext/"/>
    
      <category term="refresh" scheme="https://yidasanqian.github.io/tags/refresh/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq Network Partitions 网络分区解决方案</title>
    <link href="https://yidasanqian.github.io/2019/04/04/Rabbitmq-Network-Partitions-%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://yidasanqian.github.io/2019/04/04/Rabbitmq-Network-Partitions-网络分区解决方案/</id>
    <published>2019-04-04T02:44:00.241Z</published>
    <updated>2019-04-08T01:48:17.519Z</updated>
    
    <content type="html"><![CDATA[<p>高可用集群环境（镜像模式）：</p><p>双节点：<br>rabbit@rabbit1（master）、rabbit@rabbit2（slave）</p><p>集群设置：</p><p>rabbit1控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p></p><p>将节点2加入到集群，rabbit2控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p></p><blockquote><p>参数“—ram”表示设置为内存节点，忽略此参数则默认为磁盘节点。可以用命令<code>rabbitmqctl change_cluster_node_type disc</code><br>改变节点类型，需要注意的是集群环境中至少有一个为磁盘节点</p></blockquote><p>最后查看集群状态：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@rabbit2:/# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@rabbit-cluster&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><p></p><p>首先解决网络分区导致队列不可用的问题，需要先设置队列的高可用策略，<br>在任意mq节点控制台执行命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p / ha-all &quot;^&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p></p><p>-p 指定vhost<br>“^” 指定策略匹配到所有队列</p><p>然后进入rabbit1控制台，编辑mq配置分区恢复处理策略：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@rabbit1:/# vim /etc/rabbitmq/rabbitmq.conf</span><br></pre></td></tr></table></figure><p></p><p>添加以下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 指定网络分区处理策略</span><br><span class="line">cluster_partition_handling = pause_if_all_down</span><br><span class="line"></span><br><span class="line">## Recovery strategy. Can be either &apos;autoheal&apos; or &apos;ignore&apos;</span><br><span class="line">cluster_partition_handling.pause_if_all_down.recover = autoheal</span><br><span class="line"></span><br><span class="line">## Node names to check</span><br><span class="line">cluster_partition_handling.pause_if_all_down.nodes.1 = rabbit@rabbit1</span><br><span class="line">cluster_partition_handling.pause_if_all_down.nodes.2 = rabbit@rabbit2</span><br></pre></td></tr></table></figure><p></p><p>RabbitMQ提供了4种处理网络分区的方式：</p><ol><li>ignore 默认，RabbitMQ不会自动做任何处理，即需要手动处理。</li><li>pause_minority 这种处理方式适合集群节点数大于2个且最好为奇数的情况，因为当网络恢复时，有可能两个节点会自动启动恢复网络分区，也有可能还是保持关闭状态。</li><li>pause_if_all_down, [nodes], ignore|autoheal RabbitMQ会自动关闭不能和[nodes]中节点通信的节点。</li><li>autoheal RabbitMQ会自动决定一个获胜的（winning）分区，然后重启不在这个分区中的节点以恢复网络分区。</li></ol><p>最后重启节点1，使策略生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高可用集群环境（镜像模式）：&lt;/p&gt;&lt;p&gt;双节点：&lt;br&gt;rabbit@rabbit1（master）、rabbit@rabbit2（slave）&lt;/p&gt;&lt;p&gt;集群设置：&lt;/p&gt;&lt;p&gt;rabbit1控制台：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://yidasanqian.github.io/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://yidasanqian.github.io/tags/RabbitMQ/"/>
    
      <category term="Network Partitions" scheme="https://yidasanqian.github.io/tags/Network-Partitions/"/>
    
      <category term="网络分区" scheme="https://yidasanqian.github.io/tags/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://yidasanqian.github.io/2019/04/03/hello-hexo/"/>
    <id>https://yidasanqian.github.io/2019/04/03/hello-hexo/</id>
    <published>2019-04-03T10:44:32.637Z</published>
    <updated>2019-04-09T01:49:51.453Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==" title="https://hexo.io/">Hexo<i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">documentation<i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=" title="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fa fa-external-link"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==" title="https://github.com/hexojs/hexo/issues">GitHub<i class="fa fa-external-link"></i></span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s" title="https://hexo.io/docs/writing.html">Writing<i class="fa fa-external-link"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=" title="https://hexo.io/docs/server.html">Server<i class="fa fa-external-link"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s" title="https://hexo.io/docs/generating.html">Generating<i class="fa fa-external-link"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s" title="https://hexo.io/docs/deployment.html">Deployment<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9oZXhvLmlvLw==&quot; title=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/spa
      
    
    </summary>
    
      <category term="other" scheme="https://yidasanqian.github.io/categories/other/"/>
    
    
      <category term="hexo" scheme="https://yidasanqian.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
