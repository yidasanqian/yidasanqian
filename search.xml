<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Skipping MapperFactoryBean with name ‘xxxMapper' mapperInterface]]></title>
    <url>%2F2019%2F04%2F10%2FSkipping-MapperFactoryBean-with-name-%E2%80%98xxxMapper-mapperInterface%2F</url>
    <content type="text"><![CDATA[解决Spring Boot应用整合Mybatis启动输出警告日志：1[main] o.m.s.mapper.ClassPathMapperScanner - Skipping MapperFactoryBean with name &apos;channelMapper&apos; and &apos;io.github.yidasanqian.dao.ChannelMapper&apos; mapperInterface. Bean already defined with the same name!这是由于mybatis-spring-boot-starter 依赖的自动配置导致的：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;只需要在应用启动类加上注解 @MapperScan 即可，1234567@MapperScan(&#123;&quot;io.github.yidasanqian.dao&quot;&#125;)@SpringCloudApplicationpublic class ChannelApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ChannelApplication.class, args); &#125;&#125;重要的是要指定扫描的mapper接口包路径，上面表示扫描包为io.github.yidasanqian.dao下的所有mapper接口定义。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>MapperFactoryBean</tag>
        <tag>MapperScan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot启动流程源码分析]]></title>
    <url>%2F2019%2F04%2F09%2FSpring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[版本：2.1.1.RELEASE使用main方法启动Spring Boot应用：123public static void main(String[] args) &#123; SpringApplication.run(DingtalkApplication.class, args);&#125;进入SpringApplication类的run方法最终实现位置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public ConfigurableApplicationContext run(String... args) &#123; // 1. 启动计时 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; // 2. 回调接口SpringBootExceptionReporter用于支持自定义spring应用程序启动错误的报告 Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 3. 配置启用Java headless模式 configureHeadlessProperty(); // 4. 获取Spring应用run方法的监听器集合并启动所有的监听器 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; // 5. 提供对用于运行SpringApplication的参数的访问 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 6. 创建和配置环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 7. 配置忽略BeanInfo类的加载 configureIgnoreBeanInfo(environment); // 8. 打印Banner Banner printedBanner = printBanner(environment); // 9. 创建ApplicationContext context = createApplicationContext(); // 10. 获取异常报告实例列表 exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); // 11. 准备应用上下文 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 12. 刷新底层的ApplicationContext refreshContext(context); // 13. protected方法，应用上下文刷新后，子类可实现此方法用于后续的操作 afterRefresh(context, applicationArguments); // 14. 打印应用启动信息 stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; // 15. 启动实现了CommandLineRunner 和 ApplicationRunner 接口的类的run方法 listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; // 16. 在run 方法结束之前立即调用，发布事件，应用程序已准备好接受服务请求 listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125;run方法源码上注释了大概流程，接下来继续深入重点流程的源码。流程4，获取Spring应用run方法的监听器集合并启动所有的监听器:getRunListeners(String[] args) 方法源码：12345 private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args));&#125;返回SpringApplicationRunListeners 实例，直接看构造方法的第二个参数的getSpringFactoriesInstances方法实现：1234567891011121314 private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; // 1. 获取类加载器 ClassLoader classLoader = getClassLoader(); // 2. 获取指定类型的工厂实现类的完全限定类名集合 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 3. 根据传入的完全限定类名集合创建对应工厂实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); // 4. 根据工厂实例上的@Order注解指定的顺序排序 AnnotationAwareOrderComparator.sort(instances); return instances;&#125;该方法第一个参数这里传入的是SpringApplicationRunListener 接口，会获取该接口所在类加载器下的“META-INF/spring.factories”属性文件设置的接口实现org.springframework.boot.context.event.EventPublishingRunListener，然后调用该类的构造方法实例化：12345678 public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; this.initialMulticaster = new SimpleApplicationEventMulticaster(); for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; this.initialMulticaster.addApplicationListener(listener); &#125;&#125;该类的主要作用是作为应用启动过程的事件发布监听器，可以看到构造方法中实例化了一个简单的应用事件多播器SimpleApplicationEventMulticaster 并遍历添加应用启动事件监听器。流程4最后调用listeners.starting() 启动监听器，实现源码：12345 @Overridepublic void starting() &#123; this.initialMulticaster.multicastEvent( new ApplicationStartingEvent(this.application, this.args));&#125;该方法多播一个ApplicationStartingEvent实例（应用启动事件），事件源是SpringApplication本身。接下来就是解析事件类型并调用对应的事件监听器了，感兴趣的可以自己深入。深入之前需要对Spring事件机制有所了解，推荐此文Spring事件机制。流程6. 创建和配置环境：prepareEnvironment(listeners, applicationArguments)方法实现：1234567891011121314151617181920 private ConfigurableEnvironment prepareEnvironment( SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // 创建环境 ConfigurableEnvironment environment = getOrCreateEnvironment(); // 配置环境 configureEnvironment(environment, applicationArguments.getSourceArgs()); // 发布环境准备事件 listeners.environmentPrepared(environment); // 绑定环境到此应用 bindToSpringApplication(environment); // 判断是否需要转换环境 if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()) .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; // 附加ConfigurationPropertySource支持到指定环境 ConfigurationPropertySources.attach(environment); return environment;&#125;其中，getOrCreateEnvironment() 方法实现：1234567891011121314 private ConfigurableEnvironment getOrCreateEnvironment() &#123; if (this.environment != null) &#123; return this.environment; &#125; // 根据ClassPath存在的类推断应用运行环境，以下都是web环境 switch (this.webApplicationType) &#123; case SERVLET: return new StandardServletEnvironment(); case REACTIVE: return new StandardReactiveWebEnvironment(); default: return new StandardEnvironment(); &#125;&#125;流程9. 创建ApplicationContext：createApplicationContext方法实现：123456789101112131415161718192021 protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: // 1. 初始化并返回org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext Class对象 contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; // 忽略异常捕获代码 &#125; // 2. 调用AnnotationConfigServletWebServerApplicationContext对象的默认构造方法实例化 return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125;流程11. 准备应用上下文：prepareContext方法实现：123456789101112131415161718192021222324252627282930313233 private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; // 1. 设置环境 context.setEnvironment(environment); // 2. 在ApplicationContext中应用任何相关的后置处理,这里为context对象的BeanFactory实例DefaultListableBeanFactory添加转换服务 postProcessApplicationContext(context); // 3. 在context刷新之前应用实现了ApplicationContextInitializer回调接口的实例进行context上下文对象的初始化 applyInitializers(context); // 4. 发布context初始化事件 listeners.contextPrepared(context); // 5. 打印应用版本信息和激活的配置文件信息active profile if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // 6. 添加名称为springApplicationArguments，springBootBanner的单例bean ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; // 7. 加载源（即main方法所在的类对象）不可变的集合对象并注册其bean到应用上下文 Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[0])); // 8. 发布应用准备事件 listeners.contextLoaded(context);&#125;应用上下文对象准备好了，接下来就进行刷新上下文操作。12. 刷新底层的ApplicationContext：refreshContext方法实现：12345678910 private void refreshContext(ConfigurableApplicationContext context) &#123; refresh(context); if (this.registerShutdownHook) &#123; try &#123; // 向JVM运行时注册一个关机钩子，在JVM关闭时同时关闭这个上下文。 context.registerShutdownHook(); &#125; ...... &#125;&#125;进入到ServletWebServerApplicationContext类的refresh(context)方法实现：1234567 @Overridepublic final void refresh() throws BeansException, IllegalStateException &#123; try &#123; super.refresh(); &#125; ......&#125;发现是直接调用的父类AbstractApplicationContext的refresh方法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 @Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 1. 准备好刷新上下文 prepareRefresh(); // 2. 告诉子类刷新内部bean工厂 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 3. 准备bean工厂以用于此上下文中 prepareBeanFactory(beanFactory); try &#123; // 4. 允许在特定的ApplicationContext实现中注册特殊的bean后置处理器 postProcessBeanFactory(beanFactory); // 5. 实例化并调用所有已注册的BeanFactoryPostProcessor bean invokeBeanFactoryPostProcessors(beanFactory); // 6. 实例化并调用所有已注册的BeanPostProcessor bean registerBeanPostProcessors(beanFactory); // 7. 初始化MessageSource用于当前上下文，提供参数化和i18n的支持 initMessageSource(); // 8. 初始化事件多路广播用于当前上下文，默认使用SimpleApplicationEventMulticaster单例bean initApplicationEventMulticaster(); // 9. 在特定上下文子类中初始化其他特殊bean。 onRefresh(); // 10. 检查监听器bean并注册它们 registerListeners(); // 11. 实例化剩余所有非懒加载的单例bean finishBeanFactoryInitialization(beanFactory); // 12. 最后一步: 发布相应的事件 finishRefresh(); &#125; catch (BeansException ex) &#123; ...... // 销毁所有创建的单例来避免悬空资源 destroyBeans(); // 重置 &apos;active&apos; 标识. cancelRefresh(ex); // 抛出异常给调用者 throw ex; &#125; finally &#123; // 重置Spring的公共反射元数据缓存 resetCommonCaches(); &#125; &#125;&#125;第一点主要做了以下操作：清除本地元数据缓存(如果有的话)，删除所有缓存的类元数据。设置其启动日期和活动标志以及执行任何属性源的初始化。第二点主要做了以下操作：将成员变量 refreshed 设为 true。为 DefaultListableBeanFactory 指定一个用于序列化的id。第三点主要做了以下操作：配置工厂的标准上下文特征，例如上下文的类加载器和后置处理程序。所有bean定义都已加载，但还没有实例化bean。第四点主要做了以下操作：注册特定应用上下文的后置处理器bean扫描basePackage指定的包路径注册被注解的类，例如@Configuration第五点主要做了以下操作：实例化并调用所有已注册的BeanFactoryPostProcessor bean，如果给定显式顺序，则遵循显式顺序分别调用实现了BeanFactoryPostProcessor接口的bean。第六点主要做了以下操作：实例化并调用所有已注册的BeanPostProcessor bean，如果给定显式顺序，则遵循显式顺序分别调用实现了BeanPostProcessor接口的bean。第九点主要做了以下操作：默认创建TomcatWebServer初始化WebApplicationContext和SerlvetContext参数第十一点完成BeanFactory的初始化并实例化剩余的单例bean：finishBeanFactoryInitialization方法实现：12345678910111213141516171819202122232425262728 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // 初始化用于此上下文的转换服务 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; // 如果没有内嵌value解析器Bean则注册一个(例如 PropertyPlaceholderConfigurer bean)，主要用于解析$&#123;&#125;占位符. if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); &#125; // 尽早地初始化LoadTimeWeaverAware bean以允许尽早地注册其变换器 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // 停止正用于类型匹配的临时类加载器 beanFactory.setTempClassLoader(null); // 缓存所有bean定义的元数据，不接受后面的改变 beanFactory.freezeConfiguration(); // 实例化所有剩余的（非懒加载）单例bean beanFactory.preInstantiateSingletons();&#125;其中重点看最后一步preInstantiateSingletons方法的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 @Overridepublic void preInstantiateSingletons() throws BeansException &#123; ...... // 迭代一个beanDefinitionNames的副本以允许init方法，这些方法又轮流注册新的bean定义。 // 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。 List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); // 触发所有非懒加载单例bean的初始化... for (String beanName : beanNames) &#123; RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 如果不是抽象的bean并且是非懒加载的单例bean，则进行 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; // 判断是否是FactoryBean，如果是则进一步判断是否需要尽早的初始化bean，否则直接初始化bean if (isFactoryBean(beanName)) &#123; Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) &#123; final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean; boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; // 触发所有可用单例bean的afterSingletonsInstantiated方法回调... for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125;接下来看getBean(beanName)方法的底层实现，是直接调用doGetBean方法，返回指定bean的实例，该实例可以是共享的或独立的：1234567891011121314151617181920212223242526272829 protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 1. 返回bean名称，必要时删除工厂前缀，并将别名解析为规范名称。 final String beanName = transformedBeanName(name); Object bean; // 2. 急切地检查单例缓存以手动地注册单例 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isTraceEnabled()) &#123; // 3. 判断该当前bean是否在创建中 if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.trace(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.trace(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; &#125; // 4. 获取给定bean实例的对象，如果是FactoryBean，则为bean实例本身或其创建的对象。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 其它情况暂不做深入研究，感兴趣的读者可以自行阅读AbstractBeanFactory#doGetBean方法源码 ...... &#125; return (T) bean;&#125;查看第二点getSingleton方法的实现：123456789101112131415161718192021222324 @Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; Object singletonObject = this.singletonObjects.get(beanName); // 如果从singletonObjects单例bean缓存中获取key为beanName的单例bean为空并且该单例bean // 当前在创建中（在整个工厂内）则从早期已实例化的单例bean缓存earlySingletonObjects中 // 检查beanName的单例对象，如果为空则进一步从singletonFactories单例工厂缓存中获取beanName为key // 的BeanFactory，如果BeanFactory不为空则获取到其管理的单例bean实例并将其缓存 // 到earlySingletonObjects对象上，最后从singletonFactories缓存中移除管理该beanName // 实例的BeanFactory对象（解决循环引用） if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject;&#125;几个重要对象说明：singletonObjects：单例bean对象的缓存，ConcurrentHashMap-&gt;{beanName:beanInstance}earlySingletonObjects: 早期的单例bean对象的缓存，HashMap-&gt;{beanName:beanInstance}singletonFactories：单例BeanFactory的缓存，HashMap-&gt;{beanName:beanFactory}, beanFactory-&gt;beanInstance查看第四点getObjectForBeanInstance方法的实现：123456789101112131415161718192021222324252627282930313233343536 protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // bean的name如果以&amp;开头，则是FactoryBean实例 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; // 验证是否是FactoryBean对象，不是则抛出异常 if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; &#125; // 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回. if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // beanInstance强转为FactoryBean FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // 如果是单例，则缓存从FactoryBean获取的对象 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); // 最终调用FactoryBean实例的getObject方法获取bean实例 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125;回到refresh方法的第十二点，最后完成上下文的刷新操作，调用LifecycleProcessor的onRefresh方法并且发布最终的ContextRefreshedEvent事件：12345678910111213141516 protected void finishRefresh() &#123; // 清除此资源加载器中的所有资源缓存。 clearResourceCaches(); // 初始化此上下文的生命周期处理器DefaultLifecycleProcessor。 initLifecycleProcessor(); // 调用DefaultLifecycleProcessor的onRefresh方法 getLifecycleProcessor().onRefresh(); // 发布最终的ContextRefreshedEvent事件 publishEvent(new ContextRefreshedEvent(this)); // 如果激活则参与到LiveBeansView MBean中 LiveBeansView.registerApplicationContext(this);&#125;子类finishRefresh方法最后启动相应的WebServer并发布事件。12345678 @Overrideprotected void finishRefresh() &#123; super.finishRefresh(); WebServer webServer = startWebServer(); if (webServer != null) &#123; publishEvent(new ServletWebServerInitializedEvent(webServer, this)); &#125;&#125;以上就是Spring Boot启动流程源码分析的完整内容，如果有问题欢迎提出！]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>doGetBean</tag>
        <tag>refreshContext</tag>
        <tag>refresh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbitmq Network Partitions 网络分区解决方案]]></title>
    <url>%2F2019%2F04%2F04%2FRabbitmq-Network-Partitions-%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[高可用集群环境（镜像模式）：双节点：rabbit@rabbit1（master）、rabbit@rabbit2（slave）集群设置：rabbit1控制台：123rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_app将节点2加入到集群，rabbit2控制台：1234rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbit@rabbit1rabbitmqctl start_app参数“—ram”表示设置为内存节点，忽略此参数则默认为磁盘节点。可以用命令rabbitmqctl change_cluster_node_type disc改变节点类型，需要注意的是集群环境中至少有一个为磁盘节点最后查看集群状态：1234567root@rabbit2:/# rabbitmqctl cluster_statusCluster status of node rabbit@rabbit2 ...[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;, &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;, &#123;cluster_name,&lt;&lt;&quot;rabbit@rabbit-cluster&quot;&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;]&#125;]首先解决网络分区导致队列不可用的问题，需要先设置队列的高可用策略，在任意mq节点控制台执行命令：1rabbitmqctl set_policy -p / ha-all &quot;^&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;-p 指定vhost“^” 指定策略匹配到所有队列然后进入rabbit1控制台，编辑mq配置分区恢复处理策略：1root@rabbit1:/# vim /etc/rabbitmq/rabbitmq.conf添加以下内容：123456789## 指定网络分区处理策略cluster_partition_handling = pause_if_all_down## Recovery strategy. Can be either &apos;autoheal&apos; or &apos;ignore&apos;cluster_partition_handling.pause_if_all_down.recover = autoheal## Node names to checkcluster_partition_handling.pause_if_all_down.nodes.1 = rabbit@rabbit1cluster_partition_handling.pause_if_all_down.nodes.2 = rabbit@rabbit2RabbitMQ提供了4种处理网络分区的方式：ignore 默认，RabbitMQ不会自动做任何处理，即需要手动处理。pause_minority 这种处理方式适合集群节点数大于2个且最好为奇数的情况，因为当网络恢复时，有可能两个节点会自动启动恢复网络分区，也有可能还是保持关闭状态。pause_if_all_down, [nodes], ignore|autoheal RabbitMQ会自动关闭不能和[nodes]中节点通信的节点。autoheal RabbitMQ会自动决定一个获胜的（winning）分区，然后重启不在这个分区中的节点以恢复网络分区。最后重启节点1，使策略生效。]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Network Partitions</tag>
        <tag>网络分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
