<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring boot中使用Elasticsearch联合查询]]></title>
    <url>%2F2019%2F05%2F29%2FSpring-boot%E4%B8%AD%E4%BD%BF%E7%94%A8Elasticsearch%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[加入Elasticsearch依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt;在application.yml文件配置Elasticsearch：123456spring: elasticsearch: rest: uris: es节点1,es节点2 username: 用户名 password: 密码推荐使用这种方式。然后就可以使用下面的代码自动装配Elasticsearch的高级版客户端：12@Autowiredprivate RestHighLevelClient restHighLevelClient;下面举例如何使用bool联合查询：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static final String DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;;public List&lt;MsgStateDTO&gt; queryMsgStateLogFromElasticsearch(String appId, String messageId, String receiver) &#123; // 使用bool联合查询需要用到BoolQueryBuilder这个构建器，must方法表示完全匹配 BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery() .must(QueryBuilders.termQuery(&quot;appId&quot;, appId)); if (!StringUtils.isEmpty(messageId)) &#123; boolQueryBuilder.must(QueryBuilders.termQuery(&quot;messageId&quot;, messageId)); &#125; if (!StringUtils.isEmpty(receiver)) &#123; boolQueryBuilder.must(QueryBuilders.termQuery(&quot;receiver&quot;, receiver)); &#125; // 这里使用RangeQueryBuilder进行日期范围查询，‘createTime’是MsgStateDTO类的属性。 // 这里表示查询到此为止3个月前的数据。 RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery(&quot;createTime.keyword&quot;) .format(DATETIME_FORMAT) .timeZone(&quot;+08:00&quot;) .from(LocalDateTime.now().minusMonths(3).format(DateTimeFormatter.ofPattern(DATETIME_FORMAT))) .to(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATETIME_FORMAT))); // 添加过滤条件 boolQueryBuilder.filter(rangeQueryBuilder); // 构建完整的查询语句，SearchSourceBuilder构建表示从第0页开始查询10条，并根据@timestamp字段倒序，然后超时10s SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder() .query(boolQueryBuilder) .size(10) .sort(new FieldSortBuilder(&quot;@timestamp&quot;).order(SortOrder.DESC)) .timeout(new TimeValue(10, TimeUnit.SECONDS)); SearchRequest searchRequest = new SearchRequest(); // 指定日志所在的索引 searchRequest.indices(INDICES_CSP_MSG_STATE); searchRequest.source(searchSourceBuilder); log.info(&quot;执行Elasticsearch查询：&#123;&#125;&quot;, searchSourceBuilder); List&lt;MsgStateDTO&gt; msgStateDTOList = Collections.emptyList(); try &#123; // 执行查询 SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT); // 结果映射 SearchHit[] hits = searchResponse.getHits().getHits(); Set&lt;MsgStateDTO&gt; msgStateDTOSet = new HashSet&lt;&gt;(); for (SearchHit hit : hits) &#123; MsgStateDTO msgStateDTO = $.json.toObject(hit.getSourceAsString(), MsgStateDTO.class); msgStateDTOSet.add(msgStateDTO); &#125; msgStateDTOList = msgStateDTOSet.stream() .sorted(Comparator.comparing(MsgStateDTO::getCreateAt).reversed()) .collect(Collectors.toList()); &#125; catch (IOException e) &#123; log.error(&quot;请求日志服务异常&quot;, e); throw new BusinessException(&quot;请求日志服务异常&quot;); &#125; return msgStateDTOList;&#125;注释写得比较详细了，不再进一步说明。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>BoolQueryBuilder</tag>
        <tag>RangeQueryBuilder</tag>
        <tag>RestHighLevelClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决由于设置Mybatis的BatchExecutor批量执行器而导致无法获取自增Id的问题]]></title>
    <url>%2F2019%2F05%2F22%2F%E8%A7%A3%E5%86%B3%E7%94%B1%E4%BA%8E%E8%AE%BE%E7%BD%AEMybatis%E7%9A%84BatchExecutor%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%99%A8%E8%80%8C%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9EId%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Mybatis中有三种Executor:SimpleExecutor — SIMPLE 就是普通的执行器。ReuseExecutor -执行器会重用预处理语句（prepared statements）BatchExecutor —它是批量执行器这些就是Mybatis的三种执行器。你可以通过配置文件的settings里面的元素defaultExecutorType，配置它，默认是采用SimpleExecutor如果你在Spring运用它，那么你可以这么配置它：12345&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;!--更新采用批量的executor --&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;BATCH&quot;/&gt; &lt;/bean&gt;或者在Spring Boot的属性文件中配置：1mybatis.executor-type=BATCH如果你在事务中有这么一段代码：123456789Media media = new Media();media.setTitle(&quot;默认用户头像&quot;);media.setMediaType(0);media.setUrl(defaultAvatarUrl);mediaMapper.insert(media);logger.info(&quot;mediaId : &quot; + media.getId());User user = new User();user.setMedia(media);userMapper.insert(user);那么就会导致Media无法获取插入数据库后的id。这是由于设置了executorType=BATCH而导致执行更新Sql时Mybatis没有提交语句到数据库。这时有两种解决方法：方法1：只需要修改Executor为其它两种SIMPLE or REUSE即可：1234&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;SIMPLE&quot;/&gt; &lt;/bean&gt;或者在Spring Boot的属性文件中配置：1mybatis.executor-type=SIMPLE方法2:在insert方法之后执行：12// 刷新批量更新语句缓存，将Sql语句发送到数据库执行sqlSession.flushStatements();以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>SimpleExecutor</tag>
        <tag>ReuseExecutor</tag>
        <tag>BatchExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis执行Sql流程源码分析]]></title>
    <url>%2F2019%2F05%2F20%2FMybatis%E6%89%A7%E8%A1%8CSql%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[环境：1mybatis-spring-boot-starter: 1.3.4在MybatisAutoConfiguration类中查看Mybatis的SqlSessionFactory接口的实现DefaultSqlSessionFactory是如何注册到Spring容器的。由于不是本文重点，这里就不贴源码了，描述下大概流程：Mybatis是通过SqlSessionFactoryBean工厂bean的方式获取bean实例的。首先通过SqlSessionFactoryBean类的buildSqlSessionFactory方法中调用xmlMapperBuilder.parse()方法将Mapper接口的Class类型作为key，MapperProxyFactory实例作为value注册到MapperRegistry类上。然后将MapperRegistry实例设置到Configuration类的mapperRegistry属性上。最后调用SqlSessionFactoryBuilder类的build方法完成SqlSessionFactory实例的创建：123public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;这里看下MapperProxyFactory类的源码：1234567891011121314151617181920212223242526272829public class MapperProxyFactory&lt;T&gt; &#123; // Mapper接口的Class类型的引用 private final Class&lt;T&gt; mapperInterface; // Mapper接口中定义的方法 private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings(&quot;unchecked&quot;) protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125;可以看到通过调用MapperProxyFactory的newInstance方法完成Mapper接口代理的生成。这里用到了Jdk的动态代理。这里说明一点，Mybatis和Spring整合使用SqlSession的实现是SqlSessionTemplate，它是线程安全的由Spring管理的单例bean。当调用Mapper接口的方法时，实际上会调用MapperProxy代理的invoke方法：123456789101112131415@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (isDefaultMethod(method)) &#123; return invokeDefaultMethod(proxy, method, args); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; // 缓存Mapper接口的方法 final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args);&#125;然后返回调用MapperMethod类的execute方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; switch (command.getType()) &#123; case INSERT: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); break; &#125; case UPDATE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); break; &#125; case DELETE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); break; &#125; case SELECT: if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; result = executeForMap(sqlSession, args); &#125; else if (method.returnsCursor()) &#123; result = executeForCursor(sqlSession, args); &#125; else &#123; Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); &#125; break; case FLUSH: result = sqlSession.flushStatements(); break; default: throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;); &#125; return result; &#125;可以看到这里通过命令模式处理对应的Sql。这里笔者选择执行一条查询命令，那么最终会调用该类的executeForMany方法：123456789101112131415161718192021private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) &#123; List&lt;E&gt; result; // 根据命名规则获取参数映射对象ParamMap Object param = method.convertArgsToSqlCommandParam(args); // 判断方法上是否有RowBounds参数，如果有则Sql语句加上 offset,limit if (method.hasRowBounds()) &#123; RowBounds rowBounds = method.extractRowBounds(args); result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds); &#125; else &#123; result = sqlSession.&lt;E&gt;selectList(command.getName(), param); &#125; // issue #510 Collections &amp; arrays support if (!method.getReturnType().isAssignableFrom(result.getClass())) &#123; if (method.getReturnType().isArray()) &#123; return convertToArray(result); &#125; else &#123; return convertToDeclaredCollection(sqlSession.getConfiguration(), result); &#125; &#125; return result;&#125;接下来进入SqlSessionTemplate的selectList方法：1234@Overridepublic &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);&#125;可以看到其实是调用的SqlSession的代理来调用实际的selectList方法。查看SqlSessionTemplate类的构造方法的源码有这一行：123this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());可知SqlSessionTemplate持有SqlSession接口的代理，其默认实现是DefaultSqlSession。查看该类的selectList方法实现：123456789101112@Overridepublic &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; // statement是Mapper接口的方法的完全限定名，这里获取对应的映射信息 MappedStatement ms = configuration.getMappedStatement(statement); return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(&quot;Error querying database. Cause: &quot; + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125;由于Mybatis默认是打开本地缓存的，即每个Session都持有Executor的引用实现CachingExecutor。接下来进入CachingExecutor的query方法：12345678@Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; // 获取绑定的sql对象 BoundSql boundSql = ms.getBoundSql(parameterObject); // 创建缓存key CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); &#125;进入BaseExecutor的query方法实现，有这么一行：1list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);继续查看queryFromDatabase方法实现，有这么一行：1list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);由于默认使用Mybatis的ExecutorType是SIMPLE，所以进入SimpleExecutor的doQuery方法实现：123456789101112131415@Override public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 1. 根据映射语句执行插件来拦截的方法调用 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 2. 预编译语句 stmt = prepareStatement(handler, ms.getStatementLog()); // 3. 执行查询 return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125; &#125;第一点，查看实现会返回RoutingStatementHandler实例，由于默认的语句类型是StatementType.PREPARED，所以该类持有PreparedStatementHandler对象的引用。第二点，prepareStatement方法实现：12345678private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123; Statement stmt; Connection connection = getConnection(statementLog); stmt = handler.prepare(connection, transaction.getTimeout()); // 委托调用PreparedStatementHandler的parameterize方法进行参数设置 handler.parameterize(stmt); return stmt; &#125;PreparedStatementHandler的parameterize方法会调用DefaultParameterHandler的setParameters方法处理参数映射：12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void setParameters(PreparedStatement ps) &#123; ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId()); // 获取参数映射列表 List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings != null) &#123; // 遍历参数映射列表 for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; Object value; // 获取属性名 String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; value = parameterObject; &#125; else &#123; MetaObject metaObject = configuration.newMetaObject(parameterObject); // 根据属性名获取属性值 value = metaObject.getValue(propertyName); &#125; // 获取参数类型处理器，假定参数是int/integer类型那么最终typeHandler实例是IntegerTypeHandler TypeHandler typeHandler = parameterMapping.getTypeHandler(); // 获取参数Jdbc类型 JdbcType jdbcType = parameterMapping.getJdbcType(); if (value == null &amp;&amp; jdbcType == null) &#123; jdbcType = configuration.getJdbcTypeForNull(); &#125; try &#123; // 设置参数，如果参数不为空最终会调用IntegerTypeHandler的setNonNullParameter方法设置对应参数值 typeHandler.setParameter(ps, i + 1, value, jdbcType); &#125; catch (TypeException e) &#123; throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e); &#125; catch (SQLException e) &#123; throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e); &#125; &#125; &#125; &#125;&#125;第三点，委托调用PreparedStatementHandler的query方法：12345678@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; // 执行语句 ps.execute(); // 处理结果并返回，唯一实现是DefaultResultSetHandler return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125;这里重点看下结果的映射，结果的类型处理和参数的类型处理都是基于TypeHandler接口的实现，可以看看其抽象类的实现BaseTypeHandler：1234567891011121314@Overridepublic T getResult(ResultSet rs, String columnName) throws SQLException &#123; T result; try &#123; result = getNullableResult(rs, columnName); &#125; catch (Exception e) &#123; throw new ResultMapException(&quot;Error attempting to get column &apos;&quot; + columnName + &quot;&apos; from result set. Cause: &quot; + e, e); &#125; if (rs.wasNull()) &#123; return null; &#125; else &#123; return result; &#125;&#125;这里getNullableResult方法是抽象方法，将由具体的子类实现。比如有个实体的属性是1private LocalDateTime createAt;那么将会使用LocalDateTimeTypeHandler类的实现，也可以指定自己的TypeHandler实现，在&lt;resultMap&gt;标签的子标签&lt;result&gt;自定义typeHandler：1&lt;result property=&quot;createAt&quot; column=&quot;create_at&quot; typeHandler=&quot;org.apache.ibatis.type.LocalDateTimeTypeHandler&quot;/&gt;到此，Mybatis的调用流程源码分析结束。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>MapperProxy</tag>
        <tag>SqlSessionFactory</tag>
        <tag>TypeHandler</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring WebMVC请求处理流程源码分析]]></title>
    <url>%2F2019%2F05%2F07%2FSpring-WebMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Spring WebMVC 版本：5.1.3.RELEASE定义一个controller12345678910111213@RequestMapping(&quot;dingtalk&quot;)@RestControllerpublic class DingtalkController &#123; @Autowired private DingTalkService dingTalkService; @GetMapping(value = &quot;contact/authscope&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE ) public Object findContactAuthScope() &#123; dingTalkService.getContactAuthScope(dingTalkService.getAccessToken()); return HttpStatus.OK; &#125;&#125;我们请求http://localhost:9000/dingtalk/contact/authscope这个URL时会调用该controller的 findContactAuthScope 方法。那么Spring MVC是怎么实现这个处理流程的呢？图源：SpringMVC流程架构图我们知道 DispatcherServlet 类是Spring MVC 的入口，每次请求都会调用它的 doService 方法，该方法又将请求委托给 doDispatch 方法处理，我们来看doDispatch方法的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 1. 获取当前请求的HandlerExecutionChain，HandlerExecutionChain持有Handler对象和HandlerInterceptor， mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 2. 获取当前请求的Handler对应的HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 如果HandlerMethod支持，处理 last-modified 请求头. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); // 请求资源未改变则中断处理直接返回 if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 3. 通过HandlerAdapter调用具体的HandlerMethod来处理请求，最后返回ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; ...... // 视图解析和显示 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; ......&#125;第1点getHandler方法的实现：1234567891011121314 @Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; // 获取当前请求的拦截器列表和Handler对象 HandlerExecutionChain handler = mapping.getHandler(request); // 这里的mapping实例是RequestMappingHandlerMapping，通过 getHandler 方法获取到的hanlder不为空 if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125;RequestMappingHandlerMapping 类用于从@Controller注解所在的类的@RequestMapping注解上构建（RequestMappingInfo）请求映射信息实例。可以看到是通过遍历HandlerMapping列表，然后调用每个HandlerMapping接口的getHandler方法，进入实现该接口的抽象类 AbstractHandlerMapping 重写的getHandler方法实现：12345678910111213141516171819202122232425262728293031 @Override@Nullablepublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 查询当前请求的HandlerMethod Object handler = getHandlerInternal(request); // 当前请求的Handler如果为空则获取默认的HandlerMethod if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // 如果handler是bean name字符串则获取对应的bean实例 if (handler instanceof String) &#123; String handlerName = (String) handler; handler = obtainApplicationContext().getBean(handlerName); &#125; // 添加HandlerMethod和HandlerInterceptor拦截器到HandlerExecutionChain中，对应handler和interceptorList成员变量 HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); ...... // 如果请求头包含Origin则进行跨域配置 if (CorsUtils.isCorsRequest(request)) &#123; CorsConfiguration globalConfig = this.corsConfigurationSource.getCorsConfiguration(request); CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig); executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain;&#125;进入到AbstractHandlerMethodMapping的getHandlerInternal方法的实现：1234567891011121314 @Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; // 查询到请求uri为 /dingtalk/contact/authscope String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); this.mappingRegistry.acquireReadLock(); try &#123; // 根据查询到的路径查询当前请求对应的HandlerMethod HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); &#125; finally &#123; this.mappingRegistry.releaseReadLock(); &#125;&#125;到这里就查到请求的uri对应的是findContactAuthScope方法。下一步执行第2点，获取HandlerMethod对应的HandlerAdapter，查看getHandlerAdapter方法实现：123456789101112 protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; // 这里返回的是 RequestMappingHandlerAdapter 实例，继承AbstractHandlerMethodAdapter // 用于支持@RequestMapping注解的类和方法 if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; ......&#125;下一步执行第3点，调用 AbstractHandlerMethodAdapter的handle方法，最终会调用子类的handleInternal方法，该方法位于RequestMappingHandlerAdapter：1234567891011121314151617181920212223242526272829303132333435363738 @Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; // 检查给定的请求是否支持（request method）方法和所需（session）会话(如果有的话) checkRequest(request); // 如果需要会话同步则运行 invokeHandlerMethod 方法在同步代码块中 if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // 没有可用的 HttpSession -&gt; 不需要互斥锁 mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // 根本不需要会话同步 ... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125;invokeHandlerMethod方法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 @Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; // 调用controller的目标方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; // 返回ModelAndView return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125;在此方法中调用了invokeAndHandle方法，实现反射调用目标方法并通过 HandlerMethodReturnValueHandler 接口的实现类处理返回结果值，然后会调用实现了ResponseBodyAdvice 接口的类的beforeBodyWrite方法处理返回值，最后通过实现了GenericHttpMessageConverter 接口的类将响应body写入输出流信息中。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>DispatcherServlet</tag>
        <tag>HandlerMapping</tag>
        <tag>HandlerAdapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决SQLFeatureNotSupportedException异常]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%A7%A3%E5%86%B3SQLFeatureNotSupportedException%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[环境：12345jdk：1.8mybatis-spring-boot-starter：2.0.1druid-spring-boot-starter: 1.1.14mysql-connector-java: 5.1.47spring-boot-starter-parent: 2.1.4.RELEASE使用Mybatis查询时出现以下异常：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192org.springframework.dao.InvalidDataAccessApiUsageException: Error attempting to get column &apos;create_at&apos; from result set. Cause: java.sql.SQLFeatureNotSupportedException; null; nested exception is java.sql.SQLFeatureNotSupportedException at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:96) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:73) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446) at com.sun.proxy.$Proxy68.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:147) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:80) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:58) at com.sun.proxy.$Proxy69.queryAllByLimit(Unknown Source) at io.github.yidasanqian.mybatisdemo.service.impl.RoleServiceImpl.queryAllByLimit(RoleServiceImpl.java:44) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) at com.sun.proxy.$Proxy72.queryAllByLimit(Unknown Source) at io.github.yidasanqian.mybatisdemo.MybatisDemoApplicationTests.testRoleQuery(MybatisDemoApplicationTests.java:45) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: java.sql.SQLFeatureNotSupportedException at com.alibaba.druid.pool.DruidPooledResultSet.getObject(DruidPooledResultSet.java:1771) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.ibatis.logging.jdbc.ResultSetLogger.invoke(ResultSetLogger.java:69) at com.sun.proxy.$Proxy94.getObject(Unknown Source) at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:38) at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:28) at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:81) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getPropertyMappingValue(DefaultResultSetHandler.java:472) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyPropertyMappings(DefaultResultSetHandler.java:441) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:404) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForSimpleResultMap(DefaultResultSetHandler.java:354) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:301) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:194) at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:65) at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:147) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) ... 51 moreMapper.xml:123456&lt;resultMap type=&quot;io.github.yidasanqian.mybatisdemo.entity.Role&quot; id=&quot;Role_ResultMap&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;createAt&quot; column=&quot;create_at&quot;/&gt; &lt;result property=&quot;updateAt&quot; column=&quot;update_at&quot;/&gt;&lt;/resultMap&gt;Role.java123456789public class Role implements Serializable &#123; private static final long serialVersionUID = -50780509322421020L; private Integer id; private String name; private LocalDateTime createAt; private LocalDateTime updateAt; // ignored getter &amp; setter&#125;原因是Druid不支持JDBC4.1及以上版本导致的，可以将mybatis-spring-boot-starter版本降为1.3.4即可解决。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Druid</tag>
        <tag>LocalDateTimeTypeHandler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你如何让Mac定时自动开关黑暗模式]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E8%AE%A9Mac%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：12345tell application &quot;System Events&quot; tell appearance preferences set dark mode to not dark mode end tellend tell然后使用crontab -e新建定时任务,英文输入法下输入命令i进入编辑模式：120 22 * * * osascript ~/ChangeDarkMode.applescript12 9 * * * osascript ~/ChangeDarkMode.applescript第一行表示每天22:00 开启黑暗模式。第二行表示每天9:12，关闭黑暗模式。最后按esc退出编辑模式，并输入命令:wq保存退出。输入命令crontab -l可查看任务是否新建成功。需要注意的是如果Mac处于睡眠状态的话定时任务是不起作用的，此时需要手动开启或关闭黑暗模式！如果你的Mac安装了Alfred，那么可以使用切换外观模式工作流脚本来手动切换黑暗模式。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>DarkMode</tag>
        <tag>AppleScript</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory和FactoryBean接口的区别]]></title>
    <url>%2F2019%2F04%2F11%2FBeanFactory%E5%92%8CFactoryBean%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Spring版本：5.1.3.RELEASEBeanFactory接口：123456789101112131415String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;Object getBean(String name) throws BeansException;&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;Object getBean(String name, Object... args) throws BeansException;&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);boolean containsBean(String name);boolean isSingleton(String name) throws NoSuchBeanDefinitionException;boolean isPrototype(String name) throws NoSuchBeanDefinitionException;boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;String[] getAliases(String name);是简单工厂模式的应用，根据传入的beanName实例化相应的实例。JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）：用于访问Spring bean容器的根接口。 这是bean容器的基本客户端视图; 其他接口（如ListableBeanFactory和org.springframework.beans.factory.config.ConfigurableBeanFactory）可用于特定目的。该接口被一些持有bean定义的对象实现，每个bean定义由一个字符串名称唯一标识。根据bean定义，工厂将返回包含对象的独立实例（Prototype设计模式）或单个共享实例（Singleton设计模式的高级替代，其中实例是工厂范围中的单例）。将返回哪种类型的实例取决于bean工厂配置：API是相同的。从Spring 2.0开始，根据具体的应用程序上下文（例如Web环境中的“request”和“session”范围），可以使用更多的scope（范围）。这种方法的重点是BeanFactory是应用组件的注册中心和集中的配置中心（例如，不再需要单个对象去读取属性文件）。有关此方法的优点的讨论，请参见”Expert One-on-One J2EE Design and Development”的第4章和第11章。请注意，依靠依赖注入（“push”配置）通过setter或构造函数来配置应用对象通常更好,而不是像BeanFactory查找一样的使用“pull”配置的任意方式。Spring的依赖注入功能是使用这个BeanFactory接口及其子接口实现的。通常，BeanFactory将加载存储在配置源（例如XML文档）中的bean定义，并使用org.springframework.beans包来配置bean。尽管如此，一种简单地实现是直接在Java代码中返回Java对象。如何存储定义没有限制：LDAP，RDBMS，XML，属性文件等。鼓励实现支持bean之间的引用（依赖注入）。与ListableBeanFactory中的方法相反，如果这是HierarchicalBeanFactory，则此接口中的所有操作也将检查父工厂。如果在此工厂实例中找不到bean，则会询问直接父工厂（从父类bean工厂中获取）。此工厂实例中的Bean应该在任何父工厂中覆盖同名的Bean。Bean工厂实现应尽可能支持标准bean生命周期接口。 完整的初始化方法及其标准顺序是：BeanNameAware 接口的 setBeanName 方法BeanClassLoaderAware 接口的 setBeanClassLoader 方法BeanFactoryAware 接口的 setBeanFactory 方法EnvironmentAware 接口的 setEnvironment 方法EmbeddedValueResolverAware 接口的 setEmbeddedValueResolver 方法ResourceLoaderAware 接口的 setResourceLoader 方法 (仅适用于在应用程序上下文（Application Context）中运行时)ApplicationEventPublisherAware 接口的 setApplicationEventPublisher 方法 (仅适用于在应用程序上下文（Application Context）中运行时)MessageSourceAware 接口的 setMessageSource 方法 (仅适用于在应用程序上下文（Application Context）中运行时)ApplicationContextAware 接口的 setApplicationContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)ServletContextAware 接口的 setServletContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)所有实现了BeanPostProcessor接口的类的 postProcessBeforeInitialization 方法InitializingBean 接口的 afterPropertiesSet 方法自定义的init方法所有实现了BeanPostProcessor接口的类的 postProcessAfterInitialization 方法关闭Bean工厂时，应用以下生命周期方法:所有实现了DestructionAwareBeanPostProcessor接口的类的 postProcessBeforeDestruction 方法DisposableBean 接口的 destroy 方法自定义的destroy 方法Spring Bean生命周期图：Spring 4.3.17.RELEASE 源码的JavaDoc文档写的也是以上流程。跟其它网上的文章写的流程有出入，应该以官方文档为准。FactoryBean接口：12345T getObject() throws Exception;Class&lt;?&gt; getObjectType();default boolean isSingleton() &#123; return true;&#125;是工厂方法模式的应用，由子类实现相应的实例。JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）：接口被BeanFactory中使用的对象所实现，这些对象本身就是单个对象的工厂。如果bean实现了这个接口，它将被用作暴露此对象的工厂，而不是直接将自己作为bean实例给暴露出来。注意：实现此接口的bean不能用作普通bean。FactoryBean是被定义成bean的形式，但是bean对象的引用（getObject()方法获得）始终是由它创建的。FactoryBeans可以支持单例和原型，可以根据需要懒惰地创建对象，也可以在启动时急切地创建对象。SmartFactoryBean接口允许公开更细粒度的行为元数据。该接口在框架内部大量使用，例如用于AOP的 org.springframework.aop.framework.ProxyFactoryBean类 或 org.springframework.jndi.JndiObjectFactoryBean类。它也可以用于定制组件;但是，这仅适用于基础架构代码。FactoryBean是一个programatic contract (编程合约)。实现不应该依赖annotation-driven (注解驱动)的注入或其他反射设施。getObjectType()和getObject()方法的调用可能在引导过程的早期发生，甚至在所有的（post-processor）后置处理器设置之前。如果您需要访问其他bean，请实现 BeanFactoryAware 并以编程方式获取它们。最后，FactoryBean对象参与包含BeanFactory的bean创建的同步。除了FactoryBean本身（或类似）中的延迟初始化之外，通常不需要内部同步。下面从源码层面深入分析二者区别：查看 BeanFactory接口的抽象类 AbstractBeanFactory的getObjectForBeanInstance方法的实现：123456789101112131415161718192021222324252627282930313233343536 protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // bean的name如果以&amp;开头，则是FactoryBean实例 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; // 验证是否是FactoryBean对象，不是则抛出异常 if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; &#125; // 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回. if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // beanInstance强转为FactoryBean FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // 如果是单例，则缓存从FactoryBean获取的对象 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); // 最终调用FactoryBean实例的getObject方法获取bean实例 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125;在getObjectFromFactoryBean方法实现中会调用doGetObjectFromFactoryBean方法：123456789101112131415161718192021 private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName) throws BeanCreationException &#123; Object object; try &#123; if (System.getSecurityManager() != null) &#123; AccessControlContext acc = getAccessControlContext(); try &#123; // 调用FactoryBean的getObject方法来返回实例 object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc); &#125; ...... &#125; else &#123; // 调用FactoryBean的getObject方法来返回实例 object = factory.getObject(); &#125; &#125; ...... return object;&#125;实现FactoryBean的类,在初始化放入容器后,通过BeanFactory的getBean方法调用时,会调用FactoryBean的getObject方法返回对应的bean实例对象,而不是像普通的bean一样直接返回bean实例.BeanFactory的常量&amp;的作用是在获取bean的时候直接返回FactoryBean的bean实例,而不是调用的getObject方法返回对应的bean实例.以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>BeanFactory</tag>
        <tag>FactoryBean</tag>
        <tag>Bean生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Skipping MapperFactoryBean with name ‘xxxMapper' mapperInterface]]></title>
    <url>%2F2019%2F04%2F10%2FSkipping-MapperFactoryBean-with-name-%E2%80%98xxxMapper-mapperInterface%2F</url>
    <content type="text"><![CDATA[解决Spring Boot应用整合Mybatis启动输出警告日志：1[main] o.m.s.mapper.ClassPathMapperScanner - Skipping MapperFactoryBean with name &apos;channelMapper&apos; and &apos;io.github.yidasanqian.dao.ChannelMapper&apos; mapperInterface. Bean already defined with the same name!这是由于mybatis-spring-boot-starter 依赖的自动配置导致的：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;只需要在应用启动类加上注解 @MapperScan 即可，1234567@MapperScan(&#123;&quot;io.github.yidasanqian.dao&quot;&#125;)@SpringCloudApplicationpublic class ChannelApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ChannelApplication.class, args); &#125;&#125;重要的是要指定扫描的mapper接口包路径，上面表示扫描包为io.github.yidasanqian.dao下的所有mapper接口定义。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>MapperFactoryBean</tag>
        <tag>MapperScan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot启动流程源码分析]]></title>
    <url>%2F2019%2F04%2F09%2FSpring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[版本：2.1.1.RELEASE使用main方法启动Spring Boot应用：123public static void main(String[] args) &#123; SpringApplication.run(DingtalkApplication.class, args);&#125;进入SpringApplication类的run方法最终实现位置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public ConfigurableApplicationContext run(String... args) &#123; // 1. 启动计时 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; // 2. 回调接口SpringBootExceptionReporter用于支持自定义spring应用程序启动错误的报告 Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 3. 配置启用Java headless模式 configureHeadlessProperty(); // 4. 获取Spring应用run方法的监听器集合并启动所有的监听器 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; // 5. 提供对用于运行SpringApplication的参数的访问 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 6. 创建和配置环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 7. 配置忽略BeanInfo类的加载 configureIgnoreBeanInfo(environment); // 8. 打印Banner Banner printedBanner = printBanner(environment); // 9. 创建ApplicationContext context = createApplicationContext(); // 10. 获取异常报告实例列表 exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); // 11. 准备应用上下文 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 12. 刷新底层的ApplicationContext refreshContext(context); // 13. protected方法，应用上下文刷新后，子类可实现此方法用于后续的操作 afterRefresh(context, applicationArguments); // 14. 打印应用启动信息 stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; // 15. 启动实现了CommandLineRunner 和 ApplicationRunner 接口的类的run方法 listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; // 16. 在run 方法结束之前立即调用，发布事件，应用程序已准备好接受服务请求 listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125;run方法源码上注释了大概流程，接下来继续深入重点流程的源码。流程4，获取Spring应用run方法的监听器集合并启动所有的监听器:getRunListeners(String[] args) 方法源码：12345 private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args));&#125;返回SpringApplicationRunListeners 实例，直接看构造方法的第二个参数的getSpringFactoriesInstances方法实现：1234567891011121314 private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; // 1. 获取类加载器 ClassLoader classLoader = getClassLoader(); // 2. 获取指定类型的工厂实现类的完全限定类名集合 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 3. 根据传入的完全限定类名集合创建对应工厂实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); // 4. 根据工厂实例上的@Order注解指定的顺序排序 AnnotationAwareOrderComparator.sort(instances); return instances;&#125;该方法第一个参数这里传入的是SpringApplicationRunListener 接口，会获取该接口所在类加载器下的“META-INF/spring.factories”属性文件设置的接口实现org.springframework.boot.context.event.EventPublishingRunListener，然后调用该类的构造方法实例化：12345678 public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; this.initialMulticaster = new SimpleApplicationEventMulticaster(); for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; this.initialMulticaster.addApplicationListener(listener); &#125;&#125;该类的主要作用是作为应用启动过程的事件发布监听器，可以看到构造方法中实例化了一个简单的应用事件多播器SimpleApplicationEventMulticaster 并遍历添加应用启动事件监听器。流程4最后调用listeners.starting() 启动监听器，实现源码：12345 @Overridepublic void starting() &#123; this.initialMulticaster.multicastEvent( new ApplicationStartingEvent(this.application, this.args));&#125;该方法多播一个ApplicationStartingEvent实例（应用启动事件），事件源是SpringApplication本身。接下来就是解析事件类型并调用对应的事件监听器了，感兴趣的可以自己深入。深入之前需要对Spring事件机制有所了解，推荐此文Spring事件机制。流程6. 创建和配置环境：prepareEnvironment(listeners, applicationArguments)方法实现：1234567891011121314151617181920 private ConfigurableEnvironment prepareEnvironment( SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // 创建环境 ConfigurableEnvironment environment = getOrCreateEnvironment(); // 配置环境 configureEnvironment(environment, applicationArguments.getSourceArgs()); // 发布环境准备事件 listeners.environmentPrepared(environment); // 绑定环境到此应用 bindToSpringApplication(environment); // 判断是否需要转换环境 if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()) .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; // 附加ConfigurationPropertySource支持到指定环境 ConfigurationPropertySources.attach(environment); return environment;&#125;其中，getOrCreateEnvironment() 方法实现：1234567891011121314 private ConfigurableEnvironment getOrCreateEnvironment() &#123; if (this.environment != null) &#123; return this.environment; &#125; // 根据ClassPath存在的类推断应用运行环境，以下都是web环境 switch (this.webApplicationType) &#123; case SERVLET: return new StandardServletEnvironment(); case REACTIVE: return new StandardReactiveWebEnvironment(); default: return new StandardEnvironment(); &#125;&#125;流程9. 创建ApplicationContext：createApplicationContext方法实现：123456789101112131415161718192021 protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: // 1. 初始化并返回org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext Class对象 contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; // 忽略异常捕获代码 &#125; // 2. 调用AnnotationConfigServletWebServerApplicationContext对象的默认构造方法实例化 return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125;流程11. 准备应用上下文：prepareContext方法实现：123456789101112131415161718192021222324252627282930313233 private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; // 1. 设置环境 context.setEnvironment(environment); // 2. 在ApplicationContext中应用任何相关的后置处理,这里为context对象的BeanFactory实例DefaultListableBeanFactory添加转换服务 postProcessApplicationContext(context); // 3. 在context刷新之前应用实现了ApplicationContextInitializer回调接口的实例进行context上下文对象的初始化 applyInitializers(context); // 4. 发布context初始化事件 listeners.contextPrepared(context); // 5. 打印应用版本信息和激活的配置文件信息active profile if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // 6. 添加名称为springApplicationArguments，springBootBanner的单例bean ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; // 7. 加载源（即main方法所在的类对象）不可变的集合对象并注册其bean到应用上下文 Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[0])); // 8. 发布应用准备事件 listeners.contextLoaded(context);&#125;应用上下文对象准备好了，接下来就进行刷新上下文操作。12. 刷新底层的ApplicationContext：refreshContext方法实现：12345678910 private void refreshContext(ConfigurableApplicationContext context) &#123; refresh(context); if (this.registerShutdownHook) &#123; try &#123; // 向JVM运行时注册一个关机钩子，在JVM关闭时同时关闭这个上下文。 context.registerShutdownHook(); &#125; ...... &#125;&#125;进入到ServletWebServerApplicationContext类的refresh(context)方法实现：1234567 @Overridepublic final void refresh() throws BeansException, IllegalStateException &#123; try &#123; super.refresh(); &#125; ......&#125;发现是直接调用的父类AbstractApplicationContext的refresh方法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 @Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 1. 准备好刷新上下文 prepareRefresh(); // 2. 告诉子类刷新内部bean工厂 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 3. 准备bean工厂以用于此上下文中 prepareBeanFactory(beanFactory); try &#123; // 4. 允许在特定的ApplicationContext实现中注册特殊的bean后置处理器 postProcessBeanFactory(beanFactory); // 5. 实例化并调用所有已注册的BeanFactoryPostProcessor bean invokeBeanFactoryPostProcessors(beanFactory); // 6. 实例化并调用所有已注册的BeanPostProcessor bean registerBeanPostProcessors(beanFactory); // 7. 初始化MessageSource用于当前上下文，提供参数化和i18n的支持 initMessageSource(); // 8. 初始化事件多路广播用于当前上下文，默认使用SimpleApplicationEventMulticaster单例bean initApplicationEventMulticaster(); // 9. 在特定上下文子类中初始化其他特殊bean。 onRefresh(); // 10. 检查监听器bean并注册它们 registerListeners(); // 11. 实例化剩余所有非懒加载的单例bean finishBeanFactoryInitialization(beanFactory); // 12. 最后一步: 发布相应的事件 finishRefresh(); &#125; catch (BeansException ex) &#123; ...... // 销毁所有创建的单例来避免悬空资源 destroyBeans(); // 重置 &apos;active&apos; 标识. cancelRefresh(ex); // 抛出异常给调用者 throw ex; &#125; finally &#123; // 重置Spring的公共反射元数据缓存 resetCommonCaches(); &#125; &#125;&#125;第一点主要做了以下操作：清除本地元数据缓存(如果有的话)，删除所有缓存的类元数据。设置其启动日期和活动标志以及执行任何属性源的初始化。第二点主要做了以下操作：将成员变量 refreshed 设为 true。为 DefaultListableBeanFactory 指定一个用于序列化的id。第三点主要做了以下操作：配置工厂的标准上下文特征，例如上下文的类加载器和后置处理程序。所有bean定义都已加载，但还没有实例化bean。第四点主要做了以下操作：注册特定应用上下文的后置处理器bean扫描basePackage指定的包路径注册被注解的类，例如@Configuration第五点主要做了以下操作：实例化并调用所有已注册的BeanFactoryPostProcessor bean，如果给定显式顺序，则遵循显式顺序分别调用实现了BeanFactoryPostProcessor接口的bean。第六点主要做了以下操作：实例化并调用所有已注册的BeanPostProcessor bean，如果给定显式顺序，则遵循显式顺序分别调用实现了BeanPostProcessor接口的bean。第九点主要做了以下操作：默认创建TomcatWebServer初始化WebApplicationContext和SerlvetContext参数第十一点完成BeanFactory的初始化并实例化剩余的单例bean：finishBeanFactoryInitialization方法实现：12345678910111213141516171819202122232425262728 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // 初始化用于此上下文的转换服务 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; // 如果没有内嵌value解析器Bean则注册一个(例如 PropertyPlaceholderConfigurer bean)，主要用于解析$&#123;&#125;占位符. if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); &#125; // 尽早地初始化LoadTimeWeaverAware bean以允许尽早地注册其变换器 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // 停止正用于类型匹配的临时类加载器 beanFactory.setTempClassLoader(null); // 缓存所有bean定义的元数据，不接受后面的改变 beanFactory.freezeConfiguration(); // 实例化所有剩余的（非懒加载）单例bean beanFactory.preInstantiateSingletons();&#125;其中重点看最后一步preInstantiateSingletons方法的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 @Overridepublic void preInstantiateSingletons() throws BeansException &#123; ...... // 迭代一个beanDefinitionNames的副本以允许init方法，这些方法又轮流注册新的bean定义。 // 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。 List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); // 触发所有非懒加载单例bean的初始化... for (String beanName : beanNames) &#123; RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 如果不是抽象的bean并且是非懒加载的单例bean，则进行 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; // 判断是否是FactoryBean，如果是则进一步判断是否需要尽早的初始化bean，否则直接初始化bean if (isFactoryBean(beanName)) &#123; Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) &#123; final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean; boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; // 触发所有可用单例bean的afterSingletonsInstantiated方法回调... for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125;接下来看getBean(beanName)方法的底层实现，是直接调用doGetBean方法，返回指定bean的实例，该实例可以是共享的或独立的：1234567891011121314151617181920212223242526272829 protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 1. 返回bean名称，必要时删除工厂前缀，并将别名解析为规范名称。 final String beanName = transformedBeanName(name); Object bean; // 2. 急切地检查单例缓存以手动地注册单例 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isTraceEnabled()) &#123; // 3. 判断该当前bean是否在创建中 if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.trace(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.trace(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; &#125; // 4. 获取给定bean实例的对象，如果是FactoryBean，则为bean实例本身或其创建的对象。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 其它情况暂不做深入研究，感兴趣的读者可以自行阅读AbstractBeanFactory#doGetBean方法源码 ...... &#125; return (T) bean;&#125;查看第二点getSingleton方法的实现：123456789101112131415161718192021222324 @Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; Object singletonObject = this.singletonObjects.get(beanName); // 如果从singletonObjects单例bean缓存中获取key为beanName的单例bean为空并且该单例bean // 当前在创建中（在整个工厂内）则从早期已实例化的单例bean缓存earlySingletonObjects中 // 检查beanName的单例对象，如果为空则进一步从singletonFactories单例工厂缓存中获取beanName为key // 的BeanFactory，如果BeanFactory不为空则获取到其管理的单例bean实例并将其缓存 // 到earlySingletonObjects对象上，最后从singletonFactories缓存中移除管理该beanName // 实例的BeanFactory对象（解决循环引用） if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject;&#125;几个重要对象说明：singletonObjects：单例bean对象的缓存，ConcurrentHashMap-&gt;{beanName:beanInstance}earlySingletonObjects: 早期的单例bean对象的缓存，HashMap-&gt;{beanName:beanInstance}singletonFactories：单例BeanFactory的缓存，HashMap-&gt;{beanName:beanFactory}, beanFactory-&gt;beanInstance查看第四点getObjectForBeanInstance方法的实现：123456789101112131415161718192021222324252627282930313233343536 protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // bean的name如果以&amp;开头，则是FactoryBean实例 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; // 验证是否是FactoryBean对象，不是则抛出异常 if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; &#125; // 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回. if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // beanInstance强转为FactoryBean FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // 如果是单例，则缓存从FactoryBean获取的对象 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); // 最终调用FactoryBean实例的getObject方法获取bean实例 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125;回到refresh方法的第十二点，最后完成上下文的刷新操作，调用LifecycleProcessor的onRefresh方法并且发布最终的ContextRefreshedEvent事件：12345678910111213141516 protected void finishRefresh() &#123; // 清除此资源加载器中的所有资源缓存。 clearResourceCaches(); // 初始化此上下文的生命周期处理器DefaultLifecycleProcessor。 initLifecycleProcessor(); // 调用DefaultLifecycleProcessor的onRefresh方法 getLifecycleProcessor().onRefresh(); // 发布最终的ContextRefreshedEvent事件 publishEvent(new ContextRefreshedEvent(this)); // 如果激活则参与到LiveBeansView MBean中 LiveBeansView.registerApplicationContext(this);&#125;子类finishRefresh方法最后启动相应的WebServer并发布事件。12345678 @Overrideprotected void finishRefresh() &#123; super.finishRefresh(); WebServer webServer = startWebServer(); if (webServer != null) &#123; publishEvent(new ServletWebServerInitializedEvent(webServer, this)); &#125;&#125;以上就是Spring Boot启动流程源码分析的完整内容，如果有问题欢迎提出！]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>doGetBean</tag>
        <tag>refreshContext</tag>
        <tag>refresh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbitmq Network Partitions 网络分区解决方案]]></title>
    <url>%2F2019%2F04%2F04%2FRabbitmq-Network-Partitions-%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[高可用集群环境（镜像模式）：双节点：rabbit@rabbit1（master）、rabbit@rabbit2（slave）集群设置：rabbit1控制台：123rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_app将节点2加入到集群，rabbit2控制台：1234rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbit@rabbit1rabbitmqctl start_app参数“—ram”表示设置为内存节点，忽略此参数则默认为磁盘节点。可以用命令rabbitmqctl change_cluster_node_type disc改变节点类型，需要注意的是集群环境中至少有一个为磁盘节点最后查看集群状态：1234567root@rabbit2:/# rabbitmqctl cluster_statusCluster status of node rabbit@rabbit2 ...[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;, &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;, &#123;cluster_name,&lt;&lt;&quot;rabbit@rabbit-cluster&quot;&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;]&#125;]首先解决网络分区导致队列不可用的问题，需要先设置队列的高可用策略，在任意mq节点控制台执行命令：1rabbitmqctl set_policy -p / ha-all &quot;^&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;-p 指定vhost“^” 指定策略匹配到所有队列然后进入rabbit1控制台，编辑mq配置分区恢复处理策略：1root@rabbit1:/# vim /etc/rabbitmq/rabbitmq.conf添加以下内容：123456789## 指定网络分区处理策略cluster_partition_handling = pause_if_all_down## Recovery strategy. Can be either &apos;autoheal&apos; or &apos;ignore&apos;cluster_partition_handling.pause_if_all_down.recover = autoheal## Node names to checkcluster_partition_handling.pause_if_all_down.nodes.1 = rabbit@rabbit1cluster_partition_handling.pause_if_all_down.nodes.2 = rabbit@rabbit2RabbitMQ提供了4种处理网络分区的方式：ignore 默认，RabbitMQ不会自动做任何处理，即需要手动处理。pause_minority 这种处理方式适合集群节点数大于2个且最好为奇数的情况，因为当网络恢复时，有可能两个节点会自动启动恢复网络分区，也有可能还是保持关闭状态。pause_if_all_down, [nodes], ignore|autoheal RabbitMQ会自动关闭不能和[nodes]中节点通信的节点。autoheal RabbitMQ会自动决定一个获胜的（winning）分区，然后重启不在这个分区中的节点以恢复网络分区。最后重启节点1，使策略生效。]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Network Partitions</tag>
        <tag>网络分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
