<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一大三千的博客</title>
  
  <subtitle>yidasanqian&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yidasanqian.github.io/"/>
  <updated>2019-05-22T05:35:46.642Z</updated>
  <id>https://yidasanqian.github.io/</id>
  
  <author>
    <name>yidasanqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决由于设置Mybatis的BatchExecutor批量执行器而导致无法获取自增Id的问题</title>
    <link href="https://yidasanqian.github.io/2019/05/22/%E8%A7%A3%E5%86%B3%E7%94%B1%E4%BA%8E%E8%AE%BE%E7%BD%AEMybatis%E7%9A%84BatchExecutor%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%99%A8%E8%80%8C%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9EId%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yidasanqian.github.io/2019/05/22/解决由于设置Mybatis的BatchExecutor批量执行器而导致无法获取自增Id的问题/</id>
    <published>2019-05-22T05:34:15.903Z</published>
    <updated>2019-05-22T05:35:46.642Z</updated>
    
    <content type="html"><![CDATA[<p>在Mybatis中有三种Executor:</p><ul><li>SimpleExecutor — SIMPLE 就是普通的执行器。</li><li>ReuseExecutor -执行器会重用预处理语句（prepared statements）</li><li>BatchExecutor —它是批量执行器</li></ul><p>这些就是Mybatis的三种执行器。你可以通过配置文件的<code>settings</code>里面的元素<code>defaultExecutorType</code>，配置它，默认是采用SimpleExecutor如果你在Spring运用它，那么你可以这么配置它：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;     </span><br><span class="line">&lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">&lt;!--更新采用批量的executor --&gt;  </span><br><span class="line">&lt;constructor-arg index=&quot;1&quot; value=&quot;BATCH&quot;/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p></p><p>或者在Spring Boot的属性文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.executor-type=BATCH</span><br></pre></td></tr></table></figure><p>如果你在事务中有这么一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Media media = new Media();</span><br><span class="line">media.setTitle(&quot;默认用户头像&quot;);</span><br><span class="line">media.setMediaType(0);</span><br><span class="line">media.setUrl(defaultAvatarUrl);</span><br><span class="line">mediaMapper.insert(media);</span><br><span class="line">logger.info(&quot;mediaId : &quot; + media.getId());</span><br><span class="line">User user = new User();</span><br><span class="line">user.setMedia(media);</span><br><span class="line">userMapper.insert(user);</span><br></pre></td></tr></table></figure><p>那么就会导致<code>Media</code>无法获取插入数据库后的id。</p><p>这是由于设置了<code>executorType=BATCH</code>而导致执行更新Sql时Mybatis没有提交语句到数据库。</p><p>这时有两种解决方法：</p><p>方法1：</p><p>只需要修改Executor为其它两种<code>SIMPLE</code> or <code>REUSE</code>即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;     </span><br><span class="line">&lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">&lt;constructor-arg index=&quot;1&quot; value=&quot;SIMPLE&quot;/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>或者在Spring Boot的属性文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.executor-type=SIMPLE</span><br></pre></td></tr></table></figure><p>方法2:</p><p>在insert方法之后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 刷新批量更新语句缓存，将Sql语句发送到数据库执行</span><br><span class="line">sqlSession.flushStatements();</span><br></pre></td></tr></table></figure><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Mybatis中有三种Executor:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SimpleExecutor — SIMPLE 就是普通的执行器。&lt;/li&gt;&lt;li&gt;ReuseExecutor -执行器会重用预处理语句（prepared statements）&lt;/li&gt;&lt;li&gt;BatchE
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="SimpleExecutor" scheme="https://yidasanqian.github.io/tags/SimpleExecutor/"/>
    
      <category term="ReuseExecutor" scheme="https://yidasanqian.github.io/tags/ReuseExecutor/"/>
    
      <category term="BatchExecutor" scheme="https://yidasanqian.github.io/tags/BatchExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis执行Sql流程源码分析</title>
    <link href="https://yidasanqian.github.io/2019/05/20/Mybatis%E6%89%A7%E8%A1%8CSql%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yidasanqian.github.io/2019/05/20/Mybatis执行Sql流程源码分析/</id>
    <published>2019-05-20T02:55:19.490Z</published>
    <updated>2019-05-20T02:55:40.054Z</updated>
    
    <content type="html"><![CDATA[<p>环境：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-spring-boot-starter: 1.3.4</span><br></pre></td></tr></table></figure><p></p><p>在<code>MybatisAutoConfiguration</code>类中查看Mybatis的<code>SqlSessionFactory</code>接口的实现<code>DefaultSqlSessionFactory</code>是如何注册到Spring容器的。</p><p>由于不是本文重点，这里就不贴源码了，描述下大概流程：</p><p>Mybatis是通过<code>SqlSessionFactoryBean</code>工厂bean的方式获取bean实例的。</p><p>首先通过<code>SqlSessionFactoryBean</code>类的<code>buildSqlSessionFactory</code>方法中调用<code>xmlMapperBuilder.parse()</code>方法<br>将<code>Mapper</code>接口的Class类型作为key，<code>MapperProxyFactory</code>实例作为value注册到<code>MapperRegistry</code>类上。</p><p>然后将<code>MapperRegistry</code>实例设置到<code>Configuration</code>类的<code>mapperRegistry</code>属性上。</p><p>最后调用<code>SqlSessionFactoryBuilder</code>类的<code>build</code>方法完成<code>SqlSessionFactory</code>实例的创建：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">   return new DefaultSqlSessionFactory(config);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>这里看下<code>MapperProxyFactory</code>类的源码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line">  // Mapper接口的Class类型的引用</span><br><span class="line">  private final Class&lt;T&gt; mapperInterface;</span><br><span class="line">  // Mapper接口中定义的方法</span><br><span class="line">  private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123;</span><br><span class="line">    this.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Class&lt;T&gt; getMapperInterface() &#123;</span><br><span class="line">    return mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123;</span><br><span class="line">    return methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到通过调用<code>MapperProxyFactory</code>的<code>newInstance</code>方法完成<code>Mapper</code>接口代理的生成。这里用到了Jdk的动态代理。</p><p>这里说明一点，Mybatis和Spring整合使用<code>SqlSession</code>的实现是<code>SqlSessionTemplate</code>，它是线程安全的由Spring管理的单例bean。</p><p>当调用<code>Mapper</code>接口的方法时，实际上会调用<code>MapperProxy</code>代理的<code>invoke</code>方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      return method.invoke(this, args);</span><br><span class="line">    &#125; else if (isDefaultMethod(method)) &#123;</span><br><span class="line">      return invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  // 缓存Mapper接口的方法</span><br><span class="line">  final MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  return mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后返回调用<code>MapperMethod</code>类的<code>execute</code>方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">   Object result;</span><br><span class="line">   switch (command.getType()) &#123;</span><br><span class="line">     case INSERT: &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     case UPDATE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     case DELETE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     case SELECT:</span><br><span class="line">       if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">         executeWithResultHandler(sqlSession, args);</span><br><span class="line">         result = null;</span><br><span class="line">       &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">         result = executeForMany(sqlSession, args);</span><br><span class="line">       &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">         result = executeForMap(sqlSession, args);</span><br><span class="line">       &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">         result = executeForCursor(sqlSession, args);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">         result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">       &#125;</span><br><span class="line">       break;</span><br><span class="line">     case FLUSH:</span><br><span class="line">       result = sqlSession.flushStatements();</span><br><span class="line">       break;</span><br><span class="line">     default:</span><br><span class="line">       throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() </span><br><span class="line">         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到这里通过命令模式处理对应的Sql。这里笔者选择执行一条查询命令，那么最终会调用该类的<code>executeForMany</code>方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  // 根据命名规则获取参数映射对象ParamMap</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  // 判断方法上是否有RowBounds参数，如果有则Sql语句加上 offset,limit</span><br><span class="line">  if (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  // issue #510 Collections &amp; arrays support</span><br><span class="line">  if (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    if (method.getReturnType().isArray()) &#123;</span><br><span class="line">      return convertToArray(result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来进入<code>SqlSessionTemplate</code>的<code>selectList</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123;</span><br><span class="line">  return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实是调用的<code>SqlSession</code>的代理来调用实际的<code>selectList</code>方法。<br>查看<code>SqlSessionTemplate</code>类的构造方法的源码有这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">                        new Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">                        new SqlSessionInterceptor());</span><br></pre></td></tr></table></figure><p>可知<code>SqlSessionTemplate</code>持有<code>SqlSession</code>接口的代理，其默认实现是<code>DefaultSqlSession</code>。查看该类的<code>selectList</code>方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    // statement是Mapper接口的方法的完全限定名，这里获取对应的映射信息</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Mybatis默认是打开本地缓存的，即每个Session都持有<code>Executor</code>的引用实现<code>CachingExecutor</code>。<br>接下来进入<code>CachingExecutor</code>的<code>query</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">   // 获取绑定的sql对象</span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">   // 创建缓存key</span><br><span class="line">   CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">   return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>进入<code>BaseExecutor</code>的query方法实现，有这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br></pre></td></tr></table></figure><p>继续查看queryFromDatabase方法实现，有这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure><p>由于默认使用Mybatis的ExecutorType是<code>SIMPLE</code>，所以进入<code>SimpleExecutor</code>的doQuery方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">   Statement stmt = null;</span><br><span class="line">   try &#123;</span><br><span class="line">     Configuration configuration = ms.getConfiguration();</span><br><span class="line">     // 1. 根据映射语句执行插件来拦截的方法调用</span><br><span class="line">     StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">     // 2. 预编译语句</span><br><span class="line">     stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">     // 3. 执行查询</span><br><span class="line">     return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     closeStatement(stmt);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第一点，查看实现会返回<code>RoutingStatementHandler</code>实例，由于默认的语句类型是<code>StatementType.PREPARED</code>，<br>所以该类持有<code>PreparedStatementHandler</code>对象的引用。</p><p>第二点，<code>prepareStatement</code>方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">   Statement stmt;</span><br><span class="line">   Connection connection = getConnection(statementLog);</span><br><span class="line">   stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">   // 委托调用PreparedStatementHandler的parameterize方法进行参数设置</span><br><span class="line">   handler.parameterize(stmt);</span><br><span class="line">   return stmt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>PreparedStatementHandler的parameterize方法会调用<code>DefaultParameterHandler</code>的<code>setParameters</code>方法处理参数映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setParameters(PreparedStatement ps) &#123;</span><br><span class="line">  ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  // 获取参数映射列表</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  if (parameterMappings != null) &#123;</span><br><span class="line">    // 遍历参数映射列表</span><br><span class="line">    for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      if (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        // 获取属性名</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params</span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; else if (parameterObject == null) &#123;</span><br><span class="line">          value = null;</span><br><span class="line">        &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          // 根据属性名获取属性值</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取参数类型处理器，假定参数是int/integer类型那么最终typeHandler实例是IntegerTypeHandler</span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        // 获取参数Jdbc类型</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        if (value == null &amp;&amp; jdbcType == null) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 设置参数，如果参数不为空最终会调用IntegerTypeHandler的setNonNullParameter方法设置对应参数值</span><br><span class="line">          typeHandler.setParameter(ps, i + 1, value, jdbcType);</span><br><span class="line">        &#125; catch (TypeException e) &#123;</span><br><span class="line">          throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">          throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三点，委托调用<code>PreparedStatementHandler</code>的query方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  // 执行语句</span><br><span class="line">  ps.execute();</span><br><span class="line">  // 处理结果并返回，唯一实现是DefaultResultSetHandler</span><br><span class="line">  return resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看下结果的映射，结果的类型处理和参数的类型处理都是基于<code>TypeHandler</code>接口的实现，可以看看其抽象类的实现<code>BaseTypeHandler</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public T getResult(ResultSet rs, String columnName) throws SQLException &#123;</span><br><span class="line">  T result;</span><br><span class="line">  try &#123;</span><br><span class="line">    result = getNullableResult(rs, columnName);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new ResultMapException(&quot;Error attempting to get column &apos;&quot; + columnName + &quot;&apos; from result set.  Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">  if (rs.wasNull()) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>getNullableResult</code>方法是抽象方法，将由具体的子类实现。比如有个实体的属性是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private LocalDateTime createAt;</span><br></pre></td></tr></table></figure><p>那么将会使用<code>LocalDateTimeTypeHandler</code>类的实现，也可以指定自己的TypeHandler实现，在<code>&lt;resultMap&gt;</code>标签<br>的子标签<code>&lt;result&gt;</code>自定义typeHandler：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result property=&quot;createAt&quot; column=&quot;create_at&quot; typeHandler=&quot;org.apache.ibatis.type.LocalDateTimeTypeHandler&quot;/&gt;</span><br></pre></td></tr></table></figure><p>到此，Mybatis的调用流程源码分析结束。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="MapperProxy" scheme="https://yidasanqian.github.io/tags/MapperProxy/"/>
    
      <category term="SqlSessionFactory" scheme="https://yidasanqian.github.io/tags/SqlSessionFactory/"/>
    
      <category term="TypeHandler" scheme="https://yidasanqian.github.io/tags/TypeHandler/"/>
    
      <category term="源码分析" scheme="https://yidasanqian.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring WebMVC请求处理流程源码分析</title>
    <link href="https://yidasanqian.github.io/2019/05/07/Spring-WebMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yidasanqian.github.io/2019/05/07/Spring-WebMVC请求处理流程源码分析/</id>
    <published>2019-05-07T07:26:03.807Z</published>
    <updated>2019-05-07T07:31:52.449Z</updated>
    
    <content type="html"><![CDATA[<p>Spring WebMVC 版本：5.1.3.RELEASE</p><p>定义一个controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;dingtalk&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class DingtalkController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DingTalkService dingTalkService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;contact/authscope&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE )</span><br><span class="line">    public Object findContactAuthScope() &#123;</span><br><span class="line">        dingTalkService.getContactAuthScope(dingTalkService.getAccessToken());</span><br><span class="line">        return HttpStatus.OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们请求<code>http://localhost:9000/dingtalk/contact/authscope</code>这个URL时会调用该controller的 findContactAuthScope 方法。<br>那么Spring MVC是怎么实现这个处理流程的呢？</p><p><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/Spring MVC处理流程图.png"></p><p>图源：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veHRkeHMvcC82NjA1NDA5Lmh0bWw=" title="https://www.cnblogs.com/xtdxs/p/6605409.html">SpringMVC流程架构图<i class="fa fa-external-link"></i></span></p><p>我们知道 DispatcherServlet 类是Spring MVC 的入口，<br>每次请求都会调用它的 doService 方法，该方法又将请求委托给 doDispatch 方法处理，我们来看doDispatch方法<br>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">   protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = null;</span><br><span class="line">boolean multipartRequestParsed = false;</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">try &#123;</span><br><span class="line">ModelAndView mv = null;</span><br><span class="line">Exception dispatchException = null;</span><br><span class="line">try &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">// 1. 获取当前请求的HandlerExecutionChain，HandlerExecutionChain持有Handler对象和HandlerInterceptor，</span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line">if (mappedHandler == null) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 获取当前请求的Handler对应的HandlerAdapter</span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">// 如果HandlerMethod支持，处理 last-modified 请求头.</span><br><span class="line">String method = request.getMethod();</span><br><span class="line">boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">// 请求资源未改变则中断处理直接返回</span><br><span class="line">if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 通过HandlerAdapter调用具体的HandlerMethod来处理请求，最后返回ModelAndView</span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">// 视图解析和显示</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1点getHandler方法的实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   @Nullable</span><br><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">if (this.handlerMappings != null) &#123;</span><br><span class="line">for (HandlerMapping mapping : this.handlerMappings) &#123;</span><br><span class="line">    // 获取当前请求的拦截器列表和Handler对象</span><br><span class="line">HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">// 这里的mapping实例是RequestMappingHandlerMapping，通过 getHandler 方法获取到的hanlder不为空</span><br><span class="line">if (handler != null) &#123;</span><br><span class="line">return handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>RequestMappingHandlerMapping 类用于从@Controller注解所在的类的@RequestMapping注解上<br>构建（RequestMappingInfo）请求映射信息实例。</p><p>可以看到是通过遍历HandlerMapping列表，然后调用每个HandlerMapping接口的getHandler方法，进入<br>实现该接口的抽象类 AbstractHandlerMapping 重写的getHandler方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">@Nullable</span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">    // 查询当前请求的HandlerMethod</span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line">// 当前请求的Handler如果为空则获取默认的HandlerMethod</span><br><span class="line">if (handler == null) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line">if (handler == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">// 如果handler是bean name字符串则获取对应的bean实例</span><br><span class="line">if (handler instanceof String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">       // 添加HandlerMethod和HandlerInterceptor拦截器到HandlerExecutionChain中，对应handler和interceptorList成员变量</span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">       // 如果请求头包含Origin则进行跨域配置</span><br><span class="line">if (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">CorsConfiguration globalConfig = this.corsConfigurationSource.getCorsConfiguration(request);</span><br><span class="line">CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到AbstractHandlerMethodMapping的getHandlerInternal方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">    // 查询到请求uri为 /dingtalk/contact/authscope</span><br><span class="line">String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">this.mappingRegistry.acquireReadLock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 根据查询到的路径查询当前请求对应的HandlerMethod</span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">this.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就查到请求的uri对应的是findContactAuthScope方法。</p><p>下一步执行第2点，获取HandlerMethod对应的HandlerAdapter，查看getHandlerAdapter方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;</span><br><span class="line">if (this.handlerAdapters != null) &#123;</span><br><span class="line">for (HandlerAdapter adapter : this.handlerAdapters) &#123;</span><br><span class="line">    // 这里返回的是 RequestMappingHandlerAdapter 实例，继承AbstractHandlerMethodAdapter </span><br><span class="line">    // 用于支持@RequestMapping注解的类和方法</span><br><span class="line">if (adapter.supports(handler)) &#123;</span><br><span class="line">return adapter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步执行第3点，调用 AbstractHandlerMethodAdapter的handle方法，最终会调用子类的handleInternal方法，<br>该方法位于RequestMappingHandlerAdapter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">protected ModelAndView handleInternal(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ModelAndView mav;</span><br><span class="line">// 检查给定的请求是否支持（request method）方法和所需（session）会话(如果有的话)</span><br><span class="line">checkRequest(request);</span><br><span class="line"></span><br><span class="line">// 如果需要会话同步则运行 invokeHandlerMethod 方法在同步代码块中</span><br><span class="line">if (this.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(false);</span><br><span class="line">if (session != null) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">synchronized (mutex) &#123;</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 没有可用的 HttpSession  -&gt; 不需要互斥锁</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 根本不需要会话同步 ...</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">return mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invokeHandlerMethod方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   @Nullable</span><br><span class="line">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">ServletWebRequest webRequest = new ServletWebRequest(request, response);</span><br><span class="line">try &#123;</span><br><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">if (this.argumentResolvers != null) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line">if (this.returnValueHandlers != null) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">ModelAndViewContainer mavContainer = new ModelAndViewContainer();</span><br><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(this.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(this.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">if (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line">LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line">           // 调用controller的目标方法</span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">           // 返回ModelAndView</span><br><span class="line">return getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">webRequest.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在此方法中调用了<code>invokeAndHandle</code>方法，实现反射调用目标方法并通过 HandlerMethodReturnValueHandler 接口的实现类处理返回结果值，<br>然后会调用实现了ResponseBodyAdvice 接口的类的beforeBodyWrite方法处理返回值，<br>最后通过实现了GenericHttpMessageConverter 接口的类将响应body写入输出流信息中。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring WebMVC 版本：5.1.3.RELEASE&lt;/p&gt;&lt;p&gt;定义一个controller&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="Spring" scheme="https://yidasanqian.github.io/categories/Spring/"/>
    
    
      <category term="DispatcherServlet" scheme="https://yidasanqian.github.io/tags/DispatcherServlet/"/>
    
      <category term="HandlerMapping" scheme="https://yidasanqian.github.io/tags/HandlerMapping/"/>
    
      <category term="HandlerAdapter" scheme="https://yidasanqian.github.io/tags/HandlerAdapter/"/>
    
  </entry>
  
  <entry>
    <title>解决SQLFeatureNotSupportedException异常</title>
    <link href="https://yidasanqian.github.io/2019/04/22/%E8%A7%A3%E5%86%B3SQLFeatureNotSupportedException%E5%BC%82%E5%B8%B8/"/>
    <id>https://yidasanqian.github.io/2019/04/22/解决SQLFeatureNotSupportedException异常/</id>
    <published>2019-04-22T06:40:23.791Z</published>
    <updated>2019-04-25T09:16:38.310Z</updated>
    
    <content type="html"><![CDATA[<p>环境：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdk：1.8</span><br><span class="line">mybatis-spring-boot-starter：2.0.1</span><br><span class="line">druid-spring-boot-starter: 1.1.14</span><br><span class="line">mysql-connector-java: 5.1.47</span><br><span class="line">spring-boot-starter-parent: 2.1.4.RELEASE</span><br></pre></td></tr></table></figure><p></p><p>使用Mybatis查询时出现以下异常：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.InvalidDataAccessApiUsageException: Error attempting to get column &apos;create_at&apos; from result set.  Cause: java.sql.SQLFeatureNotSupportedException</span><br><span class="line">; null; nested exception is java.sql.SQLFeatureNotSupportedException</span><br><span class="line"></span><br><span class="line">at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:96)</span><br><span class="line">at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72)</span><br><span class="line">at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81)</span><br><span class="line">at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:73)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446)</span><br><span class="line">at com.sun.proxy.$Proxy68.selectList(Unknown Source)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230)</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:147)</span><br><span class="line">at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:80)</span><br><span class="line">at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:58)</span><br><span class="line">at com.sun.proxy.$Proxy69.queryAllByLimit(Unknown Source)</span><br><span class="line">at io.github.yidasanqian.mybatisdemo.service.impl.RoleServiceImpl.queryAllByLimit(RoleServiceImpl.java:44)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)</span><br><span class="line">at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)</span><br><span class="line">at com.sun.proxy.$Proxy72.queryAllByLimit(Unknown Source)</span><br><span class="line">at io.github.yidasanqian.mybatisdemo.MybatisDemoApplicationTests.testRoleQuery(MybatisDemoApplicationTests.java:45)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84)</span><br><span class="line">at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)</span><br><span class="line">at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)</span><br><span class="line">at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97)</span><br><span class="line">at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</span><br><span class="line">at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</span><br><span class="line">at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</span><br><span class="line">at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</span><br><span class="line">at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)</span><br><span class="line">at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)</span><br><span class="line">at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</span><br><span class="line">at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:137)</span><br><span class="line">at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)</span><br><span class="line">at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)</span><br><span class="line">Caused by: java.sql.SQLFeatureNotSupportedException</span><br><span class="line">at com.alibaba.druid.pool.DruidPooledResultSet.getObject(DruidPooledResultSet.java:1771)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.ibatis.logging.jdbc.ResultSetLogger.invoke(ResultSetLogger.java:69)</span><br><span class="line">at com.sun.proxy.$Proxy94.getObject(Unknown Source)</span><br><span class="line">at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:38)</span><br><span class="line">at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:28)</span><br><span class="line">at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:81)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getPropertyMappingValue(DefaultResultSetHandler.java:472)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyPropertyMappings(DefaultResultSetHandler.java:441)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:404)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForSimpleResultMap(DefaultResultSetHandler.java:354)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:301)</span><br><span class="line">at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:194)</span><br><span class="line">at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:65)</span><br><span class="line">at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79)</span><br><span class="line">at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324)</span><br><span class="line">at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)</span><br><span class="line">at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)</span><br><span class="line">at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:147)</span><br><span class="line">at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433)</span><br><span class="line">... 51 more</span><br></pre></td></tr></table></figure><p></p><p>Mapper.xml:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;io.github.yidasanqian.mybatisdemo.entity.Role&quot; id=&quot;Role_ResultMap&quot;&gt;</span><br><span class="line">    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;createAt&quot; column=&quot;create_at&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;updateAt&quot; column=&quot;update_at&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p></p><p>Role.java<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Role implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -50780509322421020L;</span><br><span class="line">    </span><br><span class="line">    private Integer id;    </span><br><span class="line">    private String name;    </span><br><span class="line">    private LocalDateTime createAt;    </span><br><span class="line">    private LocalDateTime updateAt;    </span><br><span class="line">    // ignored getter &amp; setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>原因是<code>Druid</code>不支持JDBC4.1及以上版本导致的，可以将<code>mybatis-spring-boot-starter</code><br>版本降为1.3.4即可解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="Druid" scheme="https://yidasanqian.github.io/tags/Druid/"/>
    
      <category term="LocalDateTimeTypeHandler" scheme="https://yidasanqian.github.io/tags/LocalDateTimeTypeHandler/"/>
    
  </entry>
  
  <entry>
    <title>教你如何让Mac定时自动开关黑暗模式</title>
    <link href="https://yidasanqian.github.io/2019/04/17/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E8%AE%A9Mac%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yidasanqian.github.io/2019/04/17/教你如何让Mac定时自动开关黑暗模式/</id>
    <published>2019-04-17T06:53:40.694Z</published>
    <updated>2019-04-17T07:21:31.847Z</updated>
    
    <content type="html"><![CDATA[<p>首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;System Events&quot;</span><br><span class="line">tell appearance preferences</span><br><span class="line">set dark mode to not dark mode</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p></p><p>然后使用<code>crontab -e</code>新建定时任务,英文输入法下输入命令<code>i</code>进入编辑模式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 22 * * * osascript ~/ChangeDarkMode.applescript</span><br><span class="line">12 9 * * * osascript ~/ChangeDarkMode.applescript</span><br></pre></td></tr></table></figure><p></p><p>第一行表示每天22:00 开启黑暗模式。第二行表示每天9:12，关闭黑暗模式。</p><p>最后按<code>esc</code>退出编辑模式，并输入命令<code>:wq</code>保存退出。</p><blockquote><p>输入命令<code>crontab -l</code>可查看任务是否新建成功。</p></blockquote><p><strong>需要注意的是如果Mac处于睡眠状态的话定时任务是不起作用的，此时需要手动开启或关闭黑暗模式！</strong></p><p>如果你的Mac安装了Alfred，那么可以使用<a href="/asserts/切换外观模式.alfredworkflow">切换外观模式</a>工作流脚本来手动切换黑暗模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="Mac" scheme="https://yidasanqian.github.io/categories/Mac/"/>
    
    
      <category term="DarkMode" scheme="https://yidasanqian.github.io/tags/DarkMode/"/>
    
      <category term="AppleScript" scheme="https://yidasanqian.github.io/tags/AppleScript/"/>
    
      <category term="crontab" scheme="https://yidasanqian.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactory和FactoryBean接口的区别</title>
    <link href="https://yidasanqian.github.io/2019/04/11/BeanFactory%E5%92%8CFactoryBean%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://yidasanqian.github.io/2019/04/11/BeanFactory和FactoryBean接口的区别/</id>
    <published>2019-04-11T06:38:56.672Z</published>
    <updated>2019-04-11T06:40:37.138Z</updated>
    
    <content type="html"><![CDATA[<p>Spring版本：5.1.3.RELEASE</p><p><code>BeanFactory</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">Object getBean(String name) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line">Object getBean(String name, Object... args) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;</span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);</span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);</span><br><span class="line">boolean containsBean(String name);</span><br><span class="line">boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class="line">Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name);</span><br></pre></td></tr></table></figure><blockquote><p>是简单工厂模式的应用，根据传入的beanName实例化相应的实例。</p></blockquote><p><strong>JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）</strong>：</p><p>用于访问Spring bean容器的根接口。 这是bean容器的基本客户端视图; 其他接口（如ListableBeanFactory和org.springframework.beans.factory.config.ConfigurableBeanFactory）可用于特定目的。</p><p>该接口被一些持有bean定义的对象实现，每个bean定义由一个字符串名称唯一标识。<br>根据bean定义，工厂将返回包含对象的独立实例（Prototype设计模式）或单个共享实例（Singleton设计模式的高级替代，其中实例是工厂范围中的单例）。</p><p>将返回哪种类型的实例取决于bean工厂配置：API是相同的。<br>从Spring 2.0开始，根据具体的应用程序上下文（例如Web环境中的“request”和“session”范围），可以使用更多的scope（范围）。</p><p>这种方法的重点是BeanFactory是应用组件的注册中心和集中的配置中心（例如，不再需要单个对象去读取属性文件）。<br>有关此方法的优点的讨论，请参见”Expert One-on-One J2EE Design and Development”的第4章和第11章。</p><p>请注意，依靠依赖注入（“push”配置）通过setter或构造函数来配置应用对象通常更好,而不是像BeanFactory查找一样的使用“pull”配置的任意方式。Spring的依赖注入功能是使用这个BeanFactory接口及其子接口实现的。</p><p>通常，BeanFactory将加载存储在配置源（例如XML文档）中的bean定义，并使用org.springframework.beans包来配置bean。尽管如此，一种简单地实现是直接在Java代码中返回Java对象。如何存储定义没有限制：LDAP，RDBMS，XML，属性文件等。鼓励实现支持bean之间的引用（依赖注入）。</p><p>与ListableBeanFactory中的方法相反，如果这是HierarchicalBeanFactory，则此接口中的所有操作也将检查父工厂。如果在此工厂实例中找不到bean，则会询问直接父工厂（从父类bean工厂中获取）。此工厂实例中的Bean应该在任何父工厂中覆盖同名的Bean。</p><p>Bean工厂实现应尽可能支持标准bean生命周期接口。 完整的初始化方法及其标准顺序是：</p><ol><li>BeanNameAware 接口的 setBeanName 方法</li><li>BeanClassLoaderAware 接口的 setBeanClassLoader 方法</li><li>BeanFactoryAware 接口的 setBeanFactory 方法</li><li>EnvironmentAware 接口的 setEnvironment 方法</li><li>EmbeddedValueResolverAware 接口的 setEmbeddedValueResolver 方法</li><li>ResourceLoaderAware 接口的 setResourceLoader 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ApplicationEventPublisherAware 接口的 setApplicationEventPublisher 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>MessageSourceAware 接口的 setMessageSource 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ApplicationContextAware 接口的 setApplicationContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ServletContextAware 接口的 setServletContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>所有实现了BeanPostProcessor接口的类的 postProcessBeforeInitialization 方法</li><li>InitializingBean 接口的 afterPropertiesSet 方法</li><li>自定义的init方法</li><li>所有实现了BeanPostProcessor接口的类的 postProcessAfterInitialization 方法</li></ol><p>关闭Bean工厂时，应用以下生命周期方法:</p><ol><li>所有实现了DestructionAwareBeanPostProcessor接口的类的 postProcessBeforeDestruction 方法</li><li>DisposableBean 接口的 destroy 方法</li><li>自定义的destroy 方法</li></ol><p><strong>Spring Bean生命周期图：</strong></p><center><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/spring-bean-lifecycle.png?x-oss-process=style/base-rule" width="55%" height="30%"></center><blockquote><p>Spring 4.3.17.RELEASE 源码的JavaDoc文档写的也是以上流程。跟其它网上的文章写的流程有出入，应该以官方文档为准。</p></blockquote><p><code>FactoryBean</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T getObject() throws Exception;</span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line">default boolean isSingleton() &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>是工厂方法模式的应用，由子类实现相应的实例。</p></blockquote><p><strong>JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）</strong>：</p><p>接口被BeanFactory中使用的对象所实现，这些对象本身就是单个对象的工厂。如果bean实现了这个接口，它将被用作暴露此对象的工厂，而不是直接将自己作为bean实例给暴露出来。</p><p><strong>注意：实现此接口的bean不能用作普通bean。</strong></p><p>FactoryBean是被定义成bean的形式，但是bean对象的引用（getObject()方法获得）始终是由它创建的。</p><p>FactoryBeans可以支持单例和原型，可以根据需要懒惰地创建对象，也可以在启动时急切地创建对象。<br>SmartFactoryBean接口允许公开更细粒度的行为元数据。</p><p>该接口在框架内部大量使用，例如用于AOP的 org.springframework.aop.framework.ProxyFactoryBean类 或 org.springframework.jndi.JndiObjectFactoryBean类。<br>它也可以用于定制组件;但是，这仅适用于基础架构代码。</p><p><strong>FactoryBean是一个programatic contract (编程合约)。实现不应该依赖annotation-driven (注解驱动)的注入或其他反射设施。</strong></p><p>getObjectType()和getObject()方法的调用可能在引导过程的早期发生，甚至在所有的（post-processor）后置处理器设置之前。<br>如果您需要访问其他bean，请实现 BeanFactoryAware 并以编程方式获取它们。</p><p>最后，FactoryBean对象参与包含BeanFactory的bean创建的同步。<br>除了FactoryBean本身（或类似）中的延迟初始化之外，通常不需要内部同步。</p><p>下面从源码层面深入分析二者区别：</p><p>查看 BeanFactory接口的抽象类 AbstractBeanFactory的getObjectForBeanInstance方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   protected Object getObjectForBeanInstance(</span><br><span class="line">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">// bean的name如果以&amp;开头，则是FactoryBean实例</span><br><span class="line">if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">// 验证是否是FactoryBean对象，不是则抛出异常</span><br><span class="line">if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回.</span><br><span class="line">if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = null;</span><br><span class="line">if (mbd == null) &#123;</span><br><span class="line">    // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">// beanInstance强转为FactoryBean</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">// 如果是单例，则缓存从FactoryBean获取的对象</span><br><span class="line">if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">// 最终调用FactoryBean实例的getObject方法获取bean实例</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getObjectFromFactoryBean方法实现中会调用doGetObjectFromFactoryBean方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)</span><br><span class="line">throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">Object object;</span><br><span class="line">try &#123;</span><br><span class="line">if (System.getSecurityManager() != null) &#123;</span><br><span class="line">AccessControlContext acc = getAccessControlContext();</span><br><span class="line">try &#123;</span><br><span class="line">    // 调用FactoryBean的getObject方法来返回实例</span><br><span class="line">object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // 调用FactoryBean的getObject方法来返回实例</span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>实现FactoryBean的类,在初始化放入容器后,通过BeanFactory的getBean方法调用时,会调用FactoryBean的getObject方法返回对应的bean实例对象,而不是像普通的bean一样直接返回bean实例.</p><p>BeanFactory的常量<code>&amp;</code>的作用是在获取bean的时候直接返回FactoryBean的bean实例,而不是调用的getObject方法返回对应的bean实例.</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring版本：5.1.3.RELEASE&lt;/p&gt;&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;接口：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Spring" scheme="https://yidasanqian.github.io/categories/Spring/"/>
    
    
      <category term="BeanFactory" scheme="https://yidasanqian.github.io/tags/BeanFactory/"/>
    
      <category term="FactoryBean" scheme="https://yidasanqian.github.io/tags/FactoryBean/"/>
    
      <category term="Bean生命周期" scheme="https://yidasanqian.github.io/tags/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Skipping MapperFactoryBean with name ‘xxxMapper&#39; mapperInterface</title>
    <link href="https://yidasanqian.github.io/2019/04/10/Skipping-MapperFactoryBean-with-name-%E2%80%98xxxMapper-mapperInterface/"/>
    <id>https://yidasanqian.github.io/2019/04/10/Skipping-MapperFactoryBean-with-name-‘xxxMapper-mapperInterface/</id>
    <published>2019-04-10T06:42:17.463Z</published>
    <updated>2019-04-10T06:44:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>解决Spring Boot应用整合Mybatis启动输出警告日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] o.m.s.mapper.ClassPathMapperScanner - Skipping MapperFactoryBean with name &apos;channelMapper&apos; and &apos;io.github.yidasanqian.dao.ChannelMapper&apos; mapperInterface. Bean already defined with the same name!</span><br></pre></td></tr></table></figure><p>这是由于mybatis-spring-boot-starter 依赖的自动配置导致的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p></p><p>只需要在应用启动类加上注解 @MapperScan 即可，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&#123;&quot;io.github.yidasanqian.dao&quot;&#125;)</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">public class ChannelApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ChannelApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是要指定扫描的mapper接口包路径，上面表示扫描包为io.github.yidasanqian.dao下的所有mapper接口定义。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决Spring Boot应用整合Mybatis启动输出警告日志：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="MapperFactoryBean" scheme="https://yidasanqian.github.io/tags/MapperFactoryBean/"/>
    
      <category term="MapperScan" scheme="https://yidasanqian.github.io/tags/MapperScan/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot启动流程源码分析</title>
    <link href="https://yidasanqian.github.io/2019/04/09/Spring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yidasanqian.github.io/2019/04/09/Spring-Boot启动流程源码分析/</id>
    <published>2019-04-09T01:47:30.663Z</published>
    <updated>2019-04-09T01:48:03.053Z</updated>
    
    <content type="html"><![CDATA[<p>版本：2.1.1.RELEASE</p><p>使用main方法启动Spring Boot应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(DingtalkApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入SpringApplication类的run方法最终实现位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    // 1. 启动计时</span><br><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">// 2. 回调接口SpringBootExceptionReporter用于支持自定义spring应用程序启动错误的报告</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">// 3. 配置启用Java headless模式 </span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">// 4. 获取Spring应用run方法的监听器集合并启动所有的监听器</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">    // 5. 提供对用于运行SpringApplication的参数的访问</span><br><span class="line">ApplicationArguments applicationArguments = new DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">// 6. 创建和配置环境</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">    // 7. 配置忽略BeanInfo类的加载</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">// 8. 打印Banner</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">// 9. 创建ApplicationContext</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">// 10. 获取异常报告实例列表</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">// 11. 准备应用上下文</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">// 12. 刷新底层的ApplicationContext</span><br><span class="line">refreshContext(context);</span><br><span class="line">// 13. protected方法，应用上下文刷新后，子类可实现此方法用于后续的操作</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">// 14. 打印应用启动信息</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">// 15. 启动实现了CommandLineRunner 和 ApplicationRunner 接口的类的run方法 </span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    // 16. 在run 方法结束之前立即调用，发布事件，应用程序已准备好接受服务请求</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run方法源码上注释了大概流程，接下来继续深入重点流程的源码。</p><p><strong>流程4，获取Spring应用run方法的监听器集合并启动所有的监听器:</strong></p><p>getRunListeners(String[] args) 方法源码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>返回SpringApplicationRunListeners 实例，直接看构造方法的第二个参数的getSpringFactoriesInstances方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">// 1. 获取类加载器</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">// 2. 获取指定类型的工厂实现类的完全限定类名集合</span><br><span class="line">Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">// 3. 根据传入的完全限定类名集合创建对应工厂实例</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">classLoader, args, names);</span><br><span class="line">    // 4. 根据工厂实例上的@Order注解指定的顺序排序</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法第一个参数这里传入的是SpringApplicationRunListener 接口，会获取该接口所在类加载器下的“META-INF/spring.factories”属性文件<br>设置的接口实现org.springframework.boot.context.event.EventPublishingRunListener，然后调用该类的构造方法实例化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">this.application = application;</span><br><span class="line">this.args = args;</span><br><span class="line">this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的主要作用是作为应用启动过程的事件发布监听器，可以看到构造方法中实例化了一个简单的应用事件多播器SimpleApplicationEventMulticaster 并遍历添加应用启动事件监听器。</p><p>流程4最后调用listeners.starting() 启动监听器，实现源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void starting() &#123;</span><br><span class="line">this.initialMulticaster.multicastEvent(</span><br><span class="line">new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法多播一个ApplicationStartingEvent实例（应用启动事件），事件源是SpringApplication本身。<br>接下来就是解析事件类型并调用对应的事件监听器了，感兴趣的可以自己深入。深入之前需要对Spring事件机制有所了解，<br>推荐此文<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kY2JlOGYwYWZiZGI=" title="https://www.jianshu.com/p/dcbe8f0afbdb">Spring事件机制<i class="fa fa-external-link"></i></span>。</p><p><strong>流程6. 创建和配置环境：</strong></p><p>prepareEnvironment(listeners, applicationArguments)方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   private ConfigurableEnvironment prepareEnvironment(</span><br><span class="line">SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments) &#123;</span><br><span class="line">// 创建环境</span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">// 配置环境</span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">// 发布环境准备事件</span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">// 绑定环境到此应用</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">// 判断是否需要转换环境</span><br><span class="line">if (!this.isCustomEnvironment) &#123;</span><br><span class="line">environment = new EnvironmentConverter(getClassLoader())</span><br><span class="line">.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">// 附加ConfigurationPropertySource支持到指定环境</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中，getOrCreateEnvironment() 方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">if (this.environment != null) &#123;</span><br><span class="line">return this.environment;</span><br><span class="line">&#125;</span><br><span class="line">// 根据ClassPath存在的类推断应用运行环境，以下都是web环境</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">return new StandardServletEnvironment();</span><br><span class="line">case REACTIVE:</span><br><span class="line">return new StandardReactiveWebEnvironment();</span><br><span class="line">default:</span><br><span class="line">return new StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程9. 创建ApplicationContext：</strong></p><p>createApplicationContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">if (contextClass == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">    // 1. 初始化并返回org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext Class对象</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 忽略异常捕获代码</span><br><span class="line">&#125;</span><br><span class="line">// 2. 调用AnnotationConfigServletWebServerApplicationContext对象的默认构造方法实例化</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>流程11. 准备应用上下文：</strong></p><p>prepareContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   private void prepareContext(ConfigurableApplicationContext context,</span><br><span class="line">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">// 1. 设置环境</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">// 2. 在ApplicationContext中应用任何相关的后置处理,这里为context对象的BeanFactory实例DefaultListableBeanFactory添加转换服务</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">// 3. 在context刷新之前应用实现了ApplicationContextInitializer回调接口的实例进行context上下文对象的初始化</span><br><span class="line">applyInitializers(context);</span><br><span class="line">// 4. 发布context初始化事件</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">// 5. 打印应用版本信息和激活的配置文件信息active profile</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == null);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line">// 6. 添加名称为springApplicationArguments，springBootBanner的单例bean</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">if (printedBanner != null) &#123;</span><br><span class="line">beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">// 7. 加载源（即main方法所在的类对象）不可变的集合对象并注册其bean到应用上下文</span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">load(context, sources.toArray(new Object[0]));</span><br><span class="line">// 8. 发布应用准备事件</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>应用上下文对象准备好了，接下来就进行刷新上下文操作。</p><p><strong>12. 刷新底层的ApplicationContext：</strong></p><p>refreshContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">refresh(context);</span><br><span class="line">if (this.registerShutdownHook) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    // 向JVM运行时注册一个关机钩子，在JVM关闭时同时关闭这个上下文。</span><br><span class="line">context.registerShutdownHook();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>进入到ServletWebServerApplicationContext类的refresh(context)方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public final void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">super.refresh();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是直接调用的父类AbstractApplicationContext的refresh方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">// 1. 准备好刷新上下文</span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line">// 2. 告诉子类刷新内部bean工厂</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">// 3. 准备bean工厂以用于此上下文中</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 4. 允许在特定的ApplicationContext实现中注册特殊的bean后置处理器</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">// 5. 实例化并调用所有已注册的BeanFactoryPostProcessor bean</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 6. 实例化并调用所有已注册的BeanPostProcessor bean</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 7. 初始化MessageSource用于当前上下文，提供参数化和i18n的支持</span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line">// 8. 初始化事件多路广播用于当前上下文，默认使用SimpleApplicationEventMulticaster单例bean</span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">// 9. 在特定上下文子类中初始化其他特殊bean。</span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line">// 10. 检查监听器bean并注册它们</span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">// 11. 实例化剩余所有非懒加载的单例bean</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">// 12. 最后一步: 发布相应的事件</span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">......</span><br><span class="line">            // 销毁所有创建的单例来避免悬空资源</span><br><span class="line">destroyBeans();</span><br><span class="line">// 重置 &apos;active&apos; 标识.</span><br><span class="line">cancelRefresh(ex);</span><br><span class="line">// 抛出异常给调用者</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">// 重置Spring的公共反射元数据缓存</span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一点主要做了以下操作：</p><ul><li>清除本地元数据缓存(如果有的话)，删除所有缓存的类元数据。</li><li>设置其启动日期和活动标志以及执行任何属性源的初始化。</li></ul><p>第二点主要做了以下操作：</p><ul><li>将成员变量 refreshed 设为 true。</li><li>为 DefaultListableBeanFactory 指定一个用于序列化的id。</li></ul><p>第三点主要做了以下操作：</p><ul><li>配置工厂的标准上下文特征，例如上下文的类加载器和后置处理程序。</li><li>所有bean定义都已加载，但还没有实例化bean。</li></ul><p>第四点主要做了以下操作：</p><ul><li>注册特定应用上下文的后置处理器bean</li><li>扫描basePackage指定的包路径</li><li>注册被注解的类，例如@Configuration</li></ul><p>第五点主要做了以下操作：</p><ul><li>实例化并调用所有已注册的BeanFactoryPostProcessor bean，如果给定显式顺序，则遵循显式顺序</li><li>分别调用实现了BeanFactoryPostProcessor接口的bean。</li></ul><p>第六点主要做了以下操作：</p><ul><li>实例化并调用所有已注册的BeanPostProcessor bean，如果给定显式顺序，则遵循显式顺序</li><li>分别调用实现了BeanPostProcessor接口的bean。</li></ul><p>第九点主要做了以下操作：</p><ul><li>默认创建TomcatWebServer</li><li>初始化WebApplicationContext和SerlvetContext参数</li></ul><p>第十一点完成BeanFactory的初始化并实例化剩余的单例bean：</p><p>finishBeanFactoryInitialization方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">// 初始化用于此上下文的转换服务</span><br><span class="line">if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果没有内嵌value解析器Bean则注册一个(例如 PropertyPlaceholderConfigurer bean)，主要用于解析$&#123;&#125;占位符.</span><br><span class="line">if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尽早地初始化LoadTimeWeaverAware bean以允许尽早地注册其变换器</span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止正用于类型匹配的临时类加载器</span><br><span class="line">beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">// 缓存所有bean定义的元数据，不接受后面的改变</span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">// 实例化所有剩余的（非懒加载）单例bean</span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中重点看最后一步preInstantiateSingletons方法的实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">// 迭代一个beanDefinitionNames的副本以允许init方法，这些方法又轮流注册新的bean定义。</span><br><span class="line">// 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。</span><br><span class="line">List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">// 触发所有非懒加载单例bean的初始化...</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">// 如果不是抽象的bean并且是非懒加载的单例bean，则进行</span><br><span class="line">if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">    // 判断是否是FactoryBean，如果是则进一步判断是否需要尽早的初始化bean，否则直接初始化bean</span><br><span class="line">if (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">if (bean instanceof FactoryBean) &#123;</span><br><span class="line">final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">boolean isEagerInit;</span><br><span class="line">if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line">if (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 触发所有可用单例bean的afterSingletonsInstantiated方法回调...</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line">if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">if (System.getSecurityManager() != null) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">return null;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来看getBean(beanName)方法的底层实现，是直接调用doGetBean方法，返回指定bean的实例，该实例可以是共享的或独立的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">       // 1. 返回bean名称，必要时删除工厂前缀，并将别名解析为规范名称。</span><br><span class="line">final String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line">// 2. 急切地检查单例缓存以手动地注册单例</span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line">if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">    // 3. 判断该当前bean是否在创建中</span><br><span class="line">if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</span><br><span class="line">&quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">logger.trace(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 4. 获取给定bean实例的对象，如果是FactoryBean，则为bean实例本身或其创建的对象。</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">    // 其它情况暂不做深入研究，感兴趣的读者可以自行阅读AbstractBeanFactory#doGetBean方法源码</span><br><span class="line">    ......</span><br><span class="line">       &#125;</span><br><span class="line">return (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看第二点getSingleton方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   @Nullable</span><br><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">// 如果从singletonObjects单例bean缓存中获取key为beanName的单例bean为空并且该单例bean</span><br><span class="line">// 当前在创建中（在整个工厂内）则从早期已实例化的单例bean缓存earlySingletonObjects中</span><br><span class="line">// 检查beanName的单例对象，如果为空则进一步从singletonFactories单例工厂缓存中获取beanName为key</span><br><span class="line">// 的BeanFactory，如果BeanFactory不为空则获取到其管理的单例bean实例并将其缓存</span><br><span class="line">// 到earlySingletonObjects对象上，最后从singletonFactories缓存中移除管理该beanName</span><br><span class="line">// 实例的BeanFactory对象（解决循环引用）</span><br><span class="line">if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">synchronized (this.singletonObjects) &#123;</span><br><span class="line">singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">if (singletonFactory != null) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">this.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要对象说明：</p><ul><li>singletonObjects：单例bean对象的缓存，ConcurrentHashMap-&gt;{beanName:beanInstance}</li><li>earlySingletonObjects: 早期的单例bean对象的缓存，HashMap-&gt;{beanName:beanInstance}</li><li>singletonFactories：单例BeanFactory的缓存，HashMap-&gt;{beanName:beanFactory}, beanFactory-&gt;beanInstance</li></ul><p>查看第四点getObjectForBeanInstance方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   protected Object getObjectForBeanInstance(</span><br><span class="line">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">// bean的name如果以&amp;开头，则是FactoryBean实例</span><br><span class="line">if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">// 验证是否是FactoryBean对象，不是则抛出异常</span><br><span class="line">if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回.</span><br><span class="line">if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = null;</span><br><span class="line">if (mbd == null) &#123;</span><br><span class="line">    // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">// beanInstance强转为FactoryBean</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">// 如果是单例，则缓存从FactoryBean获取的对象</span><br><span class="line">if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">// 最终调用FactoryBean实例的getObject方法获取bean实例</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到refresh方法的第十二点，最后完成上下文的刷新操作，调用LifecycleProcessor的onRefresh方法并且发布最终的ContextRefreshedEvent事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   protected void finishRefresh() &#123;</span><br><span class="line">// 清除此资源加载器中的所有资源缓存。</span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line">// 初始化此上下文的生命周期处理器DefaultLifecycleProcessor。</span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">// 调用DefaultLifecycleProcessor的onRefresh方法</span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">// 发布最终的ContextRefreshedEvent事件</span><br><span class="line">publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line"></span><br><span class="line">// 如果激活则参与到LiveBeansView MBean中</span><br><span class="line">LiveBeansView.registerApplicationContext(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类finishRefresh方法最后启动相应的WebServer并发布事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">protected void finishRefresh() &#123;</span><br><span class="line">super.finishRefresh();</span><br><span class="line">WebServer webServer = startWebServer();</span><br><span class="line">if (webServer != null) &#123;</span><br><span class="line">publishEvent(new ServletWebServerInitializedEvent(webServer, this));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<strong>Spring Boot启动流程源码分析</strong>的完整内容，如果有问题欢迎提出！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版本：2.1.1.RELEASE&lt;/p&gt;&lt;p&gt;使用main方法启动Spring Boot应用：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://yidasanqian.github.io/categories/Spring-Boot/"/>
    
    
      <category term="源码分析" scheme="https://yidasanqian.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="doGetBean" scheme="https://yidasanqian.github.io/tags/doGetBean/"/>
    
      <category term="refreshContext" scheme="https://yidasanqian.github.io/tags/refreshContext/"/>
    
      <category term="refresh" scheme="https://yidasanqian.github.io/tags/refresh/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq Network Partitions 网络分区解决方案</title>
    <link href="https://yidasanqian.github.io/2019/04/04/Rabbitmq-Network-Partitions-%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://yidasanqian.github.io/2019/04/04/Rabbitmq-Network-Partitions-网络分区解决方案/</id>
    <published>2019-04-04T02:44:00.241Z</published>
    <updated>2019-04-08T01:48:17.519Z</updated>
    
    <content type="html"><![CDATA[<p>高可用集群环境（镜像模式）：</p><p>双节点：<br>rabbit@rabbit1（master）、rabbit@rabbit2（slave）</p><p>集群设置：</p><p>rabbit1控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p></p><p>将节点2加入到集群，rabbit2控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p></p><blockquote><p>参数“—ram”表示设置为内存节点，忽略此参数则默认为磁盘节点。可以用命令<code>rabbitmqctl change_cluster_node_type disc</code><br>改变节点类型，需要注意的是集群环境中至少有一个为磁盘节点</p></blockquote><p>最后查看集群状态：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@rabbit2:/# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@rabbit-cluster&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><p></p><p>首先解决网络分区导致队列不可用的问题，需要先设置队列的高可用策略，<br>在任意mq节点控制台执行命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p / ha-all &quot;^&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p></p><p>-p 指定vhost<br>“^” 指定策略匹配到所有队列</p><p>然后进入rabbit1控制台，编辑mq配置分区恢复处理策略：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@rabbit1:/# vim /etc/rabbitmq/rabbitmq.conf</span><br></pre></td></tr></table></figure><p></p><p>添加以下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 指定网络分区处理策略</span><br><span class="line">cluster_partition_handling = pause_if_all_down</span><br><span class="line"></span><br><span class="line">## Recovery strategy. Can be either &apos;autoheal&apos; or &apos;ignore&apos;</span><br><span class="line">cluster_partition_handling.pause_if_all_down.recover = autoheal</span><br><span class="line"></span><br><span class="line">## Node names to check</span><br><span class="line">cluster_partition_handling.pause_if_all_down.nodes.1 = rabbit@rabbit1</span><br><span class="line">cluster_partition_handling.pause_if_all_down.nodes.2 = rabbit@rabbit2</span><br></pre></td></tr></table></figure><p></p><p>RabbitMQ提供了4种处理网络分区的方式：</p><ol><li>ignore 默认，RabbitMQ不会自动做任何处理，即需要手动处理。</li><li>pause_minority 这种处理方式适合集群节点数大于2个且最好为奇数的情况，因为当网络恢复时，有可能两个节点会自动启动恢复网络分区，也有可能还是保持关闭状态。</li><li>pause_if_all_down, [nodes], ignore|autoheal RabbitMQ会自动关闭不能和[nodes]中节点通信的节点。</li><li>autoheal RabbitMQ会自动决定一个获胜的（winning）分区，然后重启不在这个分区中的节点以恢复网络分区。</li></ol><p>最后重启节点1，使策略生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高可用集群环境（镜像模式）：&lt;/p&gt;&lt;p&gt;双节点：&lt;br&gt;rabbit@rabbit1（master）、rabbit@rabbit2（slave）&lt;/p&gt;&lt;p&gt;集群设置：&lt;/p&gt;&lt;p&gt;rabbit1控制台：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://yidasanqian.github.io/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://yidasanqian.github.io/tags/RabbitMQ/"/>
    
      <category term="Network Partitions" scheme="https://yidasanqian.github.io/tags/Network-Partitions/"/>
    
      <category term="网络分区" scheme="https://yidasanqian.github.io/tags/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://yidasanqian.github.io/2019/04/03/hello-hexo/"/>
    <id>https://yidasanqian.github.io/2019/04/03/hello-hexo/</id>
    <published>2019-04-03T10:44:32.637Z</published>
    <updated>2019-04-09T01:49:51.453Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==" title="https://hexo.io/">Hexo<i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">documentation<i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=" title="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fa fa-external-link"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==" title="https://github.com/hexojs/hexo/issues">GitHub<i class="fa fa-external-link"></i></span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s" title="https://hexo.io/docs/writing.html">Writing<i class="fa fa-external-link"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=" title="https://hexo.io/docs/server.html">Server<i class="fa fa-external-link"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s" title="https://hexo.io/docs/generating.html">Generating<i class="fa fa-external-link"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s" title="https://hexo.io/docs/deployment.html">Deployment<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9oZXhvLmlvLw==&quot; title=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/spa
      
    
    </summary>
    
      <category term="other" scheme="https://yidasanqian.github.io/categories/other/"/>
    
    
      <category term="hexo" scheme="https://yidasanqian.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
