<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一大三千</title>
  
  <subtitle>yidasanqian&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yidasanqian.github.io/"/>
  <updated>2019-04-17T07:21:31.847Z</updated>
  <id>https://yidasanqian.github.io/</id>
  
  <author>
    <name>yidasanqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>教你如何让Mac定时自动开关黑暗模式</title>
    <link href="https://yidasanqian.github.io/2019/04/17/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E8%AE%A9Mac%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yidasanqian.github.io/2019/04/17/教你如何让Mac定时自动开关黑暗模式/</id>
    <published>2019-04-17T06:53:40.694Z</published>
    <updated>2019-04-17T07:21:31.847Z</updated>
    
    <content type="html"><![CDATA[<p>首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;System Events&quot;</span><br><span class="line">tell appearance preferences</span><br><span class="line">set dark mode to not dark mode</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p></p><p>然后使用<code>crontab -e</code>新建定时任务,英文输入法下输入命令<code>i</code>进入编辑模式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 22 * * * osascript ~/ChangeDarkMode.applescript</span><br><span class="line">12 9 * * * osascript ~/ChangeDarkMode.applescript</span><br></pre></td></tr></table></figure><p></p><p>第一行表示每天22:00 开启黑暗模式。第二行表示每天9:12，关闭黑暗模式。</p><p>最后按<code>esc</code>退出编辑模式，并输入命令<code>:wq</code>保存退出。</p><blockquote><p>输入命令<code>crontab -l</code>可查看任务是否新建成功。</p></blockquote><p><strong>需要注意的是如果Mac处于睡眠状态的话定时任务是不起作用的，此时需要手动开启或关闭黑暗模式！</strong></p><p>如果你的Mac安装了Alfred，那么可以使用<a href="/asserts/切换外观模式.alfredworkflow">切换外观模式</a>工作流脚本来手动切换黑暗模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="Mac" scheme="https://yidasanqian.github.io/categories/Mac/"/>
    
    
      <category term="DarkMode" scheme="https://yidasanqian.github.io/tags/DarkMode/"/>
    
      <category term="AppleScript" scheme="https://yidasanqian.github.io/tags/AppleScript/"/>
    
      <category term="crontab" scheme="https://yidasanqian.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactory和FactoryBean接口的区别</title>
    <link href="https://yidasanqian.github.io/2019/04/11/BeanFactory%E5%92%8CFactoryBean%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://yidasanqian.github.io/2019/04/11/BeanFactory和FactoryBean接口的区别/</id>
    <published>2019-04-11T06:38:56.672Z</published>
    <updated>2019-04-11T06:40:37.138Z</updated>
    
    <content type="html"><![CDATA[<p>Spring版本：5.1.3.RELEASE</p><p><code>BeanFactory</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">Object getBean(String name) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line">Object getBean(String name, Object... args) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;</span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);</span><br><span class="line">&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);</span><br><span class="line">boolean containsBean(String name);</span><br><span class="line">boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class="line">boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</span><br><span class="line">Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name);</span><br></pre></td></tr></table></figure><blockquote><p>是简单工厂模式的应用，根据传入的beanName实例化相应的实例。</p></blockquote><p><strong>JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）</strong>：</p><p>用于访问Spring bean容器的根接口。 这是bean容器的基本客户端视图; 其他接口（如ListableBeanFactory和org.springframework.beans.factory.config.ConfigurableBeanFactory）可用于特定目的。</p><p>该接口被一些持有bean定义的对象实现，每个bean定义由一个字符串名称唯一标识。<br>根据bean定义，工厂将返回包含对象的独立实例（Prototype设计模式）或单个共享实例（Singleton设计模式的高级替代，其中实例是工厂范围中的单例）。</p><p>将返回哪种类型的实例取决于bean工厂配置：API是相同的。<br>从Spring 2.0开始，根据具体的应用程序上下文（例如Web环境中的“request”和“session”范围），可以使用更多的scope（范围）。</p><p>这种方法的重点是BeanFactory是应用组件的注册中心和集中的配置中心（例如，不再需要单个对象去读取属性文件）。<br>有关此方法的优点的讨论，请参见”Expert One-on-One J2EE Design and Development”的第4章和第11章。</p><p>请注意，依靠依赖注入（“push”配置）通过setter或构造函数来配置应用对象通常更好,而不是像BeanFactory查找一样的使用“pull”配置的任意方式。Spring的依赖注入功能是使用这个BeanFactory接口及其子接口实现的。</p><p>通常，BeanFactory将加载存储在配置源（例如XML文档）中的bean定义，并使用org.springframework.beans包来配置bean。尽管如此，一种简单地实现是直接在Java代码中返回Java对象。如何存储定义没有限制：LDAP，RDBMS，XML，属性文件等。鼓励实现支持bean之间的引用（依赖注入）。</p><p>与ListableBeanFactory中的方法相反，如果这是HierarchicalBeanFactory，则此接口中的所有操作也将检查父工厂。如果在此工厂实例中找不到bean，则会询问直接父工厂（从父类bean工厂中获取）。此工厂实例中的Bean应该在任何父工厂中覆盖同名的Bean。</p><p>Bean工厂实现应尽可能支持标准bean生命周期接口。 完整的初始化方法及其标准顺序是：</p><ol><li>BeanNameAware 接口的 setBeanName 方法</li><li>BeanClassLoaderAware 接口的 setBeanClassLoader 方法</li><li>BeanFactoryAware 接口的 setBeanFactory 方法</li><li>EnvironmentAware 接口的 setEnvironment 方法</li><li>EmbeddedValueResolverAware 接口的 setEmbeddedValueResolver 方法</li><li>ResourceLoaderAware 接口的 setResourceLoader 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ApplicationEventPublisherAware 接口的 setApplicationEventPublisher 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>MessageSourceAware 接口的 setMessageSource 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ApplicationContextAware 接口的 setApplicationContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>ServletContextAware 接口的 setServletContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)</li><li>所有实现了BeanPostProcessor接口的类的 postProcessBeforeInitialization 方法</li><li>InitializingBean 接口的 afterPropertiesSet 方法</li><li>自定义的init方法</li><li>所有实现了BeanPostProcessor接口的类的 postProcessAfterInitialization 方法</li></ol><p>关闭Bean工厂时，应用以下生命周期方法:</p><ol><li>所有实现了DestructionAwareBeanPostProcessor接口的类的 postProcessBeforeDestruction 方法</li><li>DisposableBean 接口的 destroy 方法</li><li>自定义的destroy 方法</li></ol><p><strong>Spring Bean生命周期图：</strong></p><center><img src="https://bed-for-picgo.oss-cn-hangzhou.aliyuncs.com/spring-bean-lifecycle.png?x-oss-process=style/base-rule" width="55%" height="30%"></center><blockquote><p>Spring 4.3.17.RELEASE 源码的JavaDoc文档写的也是以上流程。跟其它网上的文章写的流程有出入，应该以官方文档为准。</p></blockquote><p><code>FactoryBean</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T getObject() throws Exception;</span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line">default boolean isSingleton() &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>是工厂方法模式的应用，由子类实现相应的实例。</p></blockquote><p><strong>JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）</strong>：</p><p>接口被BeanFactory中使用的对象所实现，这些对象本身就是单个对象的工厂。如果bean实现了这个接口，它将被用作暴露此对象的工厂，而不是直接将自己作为bean实例给暴露出来。</p><p><strong>注意：实现此接口的bean不能用作普通bean。</strong></p><p>FactoryBean是被定义成bean的形式，但是bean对象的引用（getObject()方法获得）始终是由它创建的。</p><p>FactoryBeans可以支持单例和原型，可以根据需要懒惰地创建对象，也可以在启动时急切地创建对象。<br>SmartFactoryBean接口允许公开更细粒度的行为元数据。</p><p>该接口在框架内部大量使用，例如用于AOP的 org.springframework.aop.framework.ProxyFactoryBean类 或 org.springframework.jndi.JndiObjectFactoryBean类。<br>它也可以用于定制组件;但是，这仅适用于基础架构代码。</p><p><strong>FactoryBean是一个programatic contract (编程合约)。实现不应该依赖annotation-driven (注解驱动)的注入或其他反射设施。</strong></p><p>getObjectType()和getObject()方法的调用可能在引导过程的早期发生，甚至在所有的（post-processor）后置处理器设置之前。<br>如果您需要访问其他bean，请实现 BeanFactoryAware 并以编程方式获取它们。</p><p>最后，FactoryBean对象参与包含BeanFactory的bean创建的同步。<br>除了FactoryBean本身（或类似）中的延迟初始化之外，通常不需要内部同步。</p><p>下面从源码层面深入分析二者区别：</p><p>查看 BeanFactory接口的抽象类 AbstractBeanFactory的getObjectForBeanInstance方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   protected Object getObjectForBeanInstance(</span><br><span class="line">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">// bean的name如果以&amp;开头，则是FactoryBean实例</span><br><span class="line">if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">// 验证是否是FactoryBean对象，不是则抛出异常</span><br><span class="line">if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回.</span><br><span class="line">if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = null;</span><br><span class="line">if (mbd == null) &#123;</span><br><span class="line">    // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">// beanInstance强转为FactoryBean</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">// 如果是单例，则缓存从FactoryBean获取的对象</span><br><span class="line">if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">// 最终调用FactoryBean实例的getObject方法获取bean实例</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在getObjectFromFactoryBean方法实现中会调用doGetObjectFromFactoryBean方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)</span><br><span class="line">throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">Object object;</span><br><span class="line">try &#123;</span><br><span class="line">if (System.getSecurityManager() != null) &#123;</span><br><span class="line">AccessControlContext acc = getAccessControlContext();</span><br><span class="line">try &#123;</span><br><span class="line">    // 调用FactoryBean的getObject方法来返回实例</span><br><span class="line">object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // 调用FactoryBean的getObject方法来返回实例</span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>实现FactoryBean的类,在初始化放入容器后,通过BeanFactory的getBean方法调用时,会调用FactoryBean的getObject方法返回对应的bean实例对象,而不是像普通的bean一样直接返回bean实例.</p><p>BeanFactory的常量<code>&amp;</code>的作用是在获取bean的时候直接返回FactoryBean的bean实例,而不是调用的getObject方法返回对应的bean实例.</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring版本：5.1.3.RELEASE&lt;/p&gt;&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;接口：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Spring" scheme="https://yidasanqian.github.io/categories/Spring/"/>
    
    
      <category term="BeanFactory" scheme="https://yidasanqian.github.io/tags/BeanFactory/"/>
    
      <category term="FactoryBean" scheme="https://yidasanqian.github.io/tags/FactoryBean/"/>
    
      <category term="Bean生命周期" scheme="https://yidasanqian.github.io/tags/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Skipping MapperFactoryBean with name ‘xxxMapper&#39; mapperInterface</title>
    <link href="https://yidasanqian.github.io/2019/04/10/Skipping-MapperFactoryBean-with-name-%E2%80%98xxxMapper-mapperInterface/"/>
    <id>https://yidasanqian.github.io/2019/04/10/Skipping-MapperFactoryBean-with-name-‘xxxMapper-mapperInterface/</id>
    <published>2019-04-10T06:42:17.463Z</published>
    <updated>2019-04-10T06:44:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>解决Spring Boot应用整合Mybatis启动输出警告日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] o.m.s.mapper.ClassPathMapperScanner - Skipping MapperFactoryBean with name &apos;channelMapper&apos; and &apos;io.github.yidasanqian.dao.ChannelMapper&apos; mapperInterface. Bean already defined with the same name!</span><br></pre></td></tr></table></figure><p>这是由于mybatis-spring-boot-starter 依赖的自动配置导致的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p></p><p>只需要在应用启动类加上注解 @MapperScan 即可，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&#123;&quot;io.github.yidasanqian.dao&quot;&#125;)</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">public class ChannelApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ChannelApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是要指定扫描的mapper接口包路径，上面表示扫描包为io.github.yidasanqian.dao下的所有mapper接口定义。</p><p><strong>以上，如有问题欢迎提出！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决Spring Boot应用整合Mybatis启动输出警告日志：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://yidasanqian.github.io/categories/Mybatis/"/>
    
    
      <category term="MapperFactoryBean" scheme="https://yidasanqian.github.io/tags/MapperFactoryBean/"/>
    
      <category term="MapperScan" scheme="https://yidasanqian.github.io/tags/MapperScan/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot启动流程源码分析</title>
    <link href="https://yidasanqian.github.io/2019/04/09/Spring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yidasanqian.github.io/2019/04/09/Spring-Boot启动流程源码分析/</id>
    <published>2019-04-09T01:47:30.663Z</published>
    <updated>2019-04-09T01:48:03.053Z</updated>
    
    <content type="html"><![CDATA[<p>版本：2.1.1.RELEASE</p><p>使用main方法启动Spring Boot应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(DingtalkApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入SpringApplication类的run方法最终实现位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    // 1. 启动计时</span><br><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">// 2. 回调接口SpringBootExceptionReporter用于支持自定义spring应用程序启动错误的报告</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">// 3. 配置启用Java headless模式 </span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">// 4. 获取Spring应用run方法的监听器集合并启动所有的监听器</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">    // 5. 提供对用于运行SpringApplication的参数的访问</span><br><span class="line">ApplicationArguments applicationArguments = new DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">// 6. 创建和配置环境</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">    // 7. 配置忽略BeanInfo类的加载</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">// 8. 打印Banner</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">// 9. 创建ApplicationContext</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">// 10. 获取异常报告实例列表</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">// 11. 准备应用上下文</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">// 12. 刷新底层的ApplicationContext</span><br><span class="line">refreshContext(context);</span><br><span class="line">// 13. protected方法，应用上下文刷新后，子类可实现此方法用于后续的操作</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">// 14. 打印应用启动信息</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">// 15. 启动实现了CommandLineRunner 和 ApplicationRunner 接口的类的run方法 </span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    // 16. 在run 方法结束之前立即调用，发布事件，应用程序已准备好接受服务请求</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run方法源码上注释了大概流程，接下来继续深入重点流程的源码。</p><p><strong>流程4，获取Spring应用run方法的监听器集合并启动所有的监听器:</strong></p><p>getRunListeners(String[] args) 方法源码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>返回SpringApplicationRunListeners 实例，直接看构造方法的第二个参数的getSpringFactoriesInstances方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">// 1. 获取类加载器</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">// 2. 获取指定类型的工厂实现类的完全限定类名集合</span><br><span class="line">Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">// 3. 根据传入的完全限定类名集合创建对应工厂实例</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">classLoader, args, names);</span><br><span class="line">    // 4. 根据工厂实例上的@Order注解指定的顺序排序</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法第一个参数这里传入的是SpringApplicationRunListener 接口，会获取该接口所在类加载器下的“META-INF/spring.factories”属性文件<br>设置的接口实现org.springframework.boot.context.event.EventPublishingRunListener，然后调用该类的构造方法实例化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">this.application = application;</span><br><span class="line">this.args = args;</span><br><span class="line">this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的主要作用是作为应用启动过程的事件发布监听器，可以看到构造方法中实例化了一个简单的应用事件多播器SimpleApplicationEventMulticaster 并遍历添加应用启动事件监听器。</p><p>流程4最后调用listeners.starting() 启动监听器，实现源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void starting() &#123;</span><br><span class="line">this.initialMulticaster.multicastEvent(</span><br><span class="line">new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法多播一个ApplicationStartingEvent实例（应用启动事件），事件源是SpringApplication本身。<br>接下来就是解析事件类型并调用对应的事件监听器了，感兴趣的可以自己深入。深入之前需要对Spring事件机制有所了解，<br>推荐此文<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kY2JlOGYwYWZiZGI=" title="https://www.jianshu.com/p/dcbe8f0afbdb">Spring事件机制<i class="fa fa-external-link"></i></span>。</p><p><strong>流程6. 创建和配置环境：</strong></p><p>prepareEnvironment(listeners, applicationArguments)方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   private ConfigurableEnvironment prepareEnvironment(</span><br><span class="line">SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments) &#123;</span><br><span class="line">// 创建环境</span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">// 配置环境</span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">// 发布环境准备事件</span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">// 绑定环境到此应用</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">// 判断是否需要转换环境</span><br><span class="line">if (!this.isCustomEnvironment) &#123;</span><br><span class="line">environment = new EnvironmentConverter(getClassLoader())</span><br><span class="line">.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">// 附加ConfigurationPropertySource支持到指定环境</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中，getOrCreateEnvironment() 方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">if (this.environment != null) &#123;</span><br><span class="line">return this.environment;</span><br><span class="line">&#125;</span><br><span class="line">// 根据ClassPath存在的类推断应用运行环境，以下都是web环境</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">return new StandardServletEnvironment();</span><br><span class="line">case REACTIVE:</span><br><span class="line">return new StandardReactiveWebEnvironment();</span><br><span class="line">default:</span><br><span class="line">return new StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程9. 创建ApplicationContext：</strong></p><p>createApplicationContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">if (contextClass == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">    // 1. 初始化并返回org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext Class对象</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 忽略异常捕获代码</span><br><span class="line">&#125;</span><br><span class="line">// 2. 调用AnnotationConfigServletWebServerApplicationContext对象的默认构造方法实例化</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>流程11. 准备应用上下文：</strong></p><p>prepareContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   private void prepareContext(ConfigurableApplicationContext context,</span><br><span class="line">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">// 1. 设置环境</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">// 2. 在ApplicationContext中应用任何相关的后置处理,这里为context对象的BeanFactory实例DefaultListableBeanFactory添加转换服务</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">// 3. 在context刷新之前应用实现了ApplicationContextInitializer回调接口的实例进行context上下文对象的初始化</span><br><span class="line">applyInitializers(context);</span><br><span class="line">// 4. 发布context初始化事件</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">// 5. 打印应用版本信息和激活的配置文件信息active profile</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == null);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line">// 6. 添加名称为springApplicationArguments，springBootBanner的单例bean</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">if (printedBanner != null) &#123;</span><br><span class="line">beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">// 7. 加载源（即main方法所在的类对象）不可变的集合对象并注册其bean到应用上下文</span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">load(context, sources.toArray(new Object[0]));</span><br><span class="line">// 8. 发布应用准备事件</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>应用上下文对象准备好了，接下来就进行刷新上下文操作。</p><p><strong>12. 刷新底层的ApplicationContext：</strong></p><p>refreshContext方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">refresh(context);</span><br><span class="line">if (this.registerShutdownHook) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    // 向JVM运行时注册一个关机钩子，在JVM关闭时同时关闭这个上下文。</span><br><span class="line">context.registerShutdownHook();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>进入到ServletWebServerApplicationContext类的refresh(context)方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public final void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">super.refresh();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是直接调用的父类AbstractApplicationContext的refresh方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">// 1. 准备好刷新上下文</span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line">// 2. 告诉子类刷新内部bean工厂</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">// 3. 准备bean工厂以用于此上下文中</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 4. 允许在特定的ApplicationContext实现中注册特殊的bean后置处理器</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">// 5. 实例化并调用所有已注册的BeanFactoryPostProcessor bean</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 6. 实例化并调用所有已注册的BeanPostProcessor bean</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 7. 初始化MessageSource用于当前上下文，提供参数化和i18n的支持</span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line">// 8. 初始化事件多路广播用于当前上下文，默认使用SimpleApplicationEventMulticaster单例bean</span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">// 9. 在特定上下文子类中初始化其他特殊bean。</span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line">// 10. 检查监听器bean并注册它们</span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">// 11. 实例化剩余所有非懒加载的单例bean</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">// 12. 最后一步: 发布相应的事件</span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">......</span><br><span class="line">            // 销毁所有创建的单例来避免悬空资源</span><br><span class="line">destroyBeans();</span><br><span class="line">// 重置 &apos;active&apos; 标识.</span><br><span class="line">cancelRefresh(ex);</span><br><span class="line">// 抛出异常给调用者</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">// 重置Spring的公共反射元数据缓存</span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一点主要做了以下操作：</p><ul><li>清除本地元数据缓存(如果有的话)，删除所有缓存的类元数据。</li><li>设置其启动日期和活动标志以及执行任何属性源的初始化。</li></ul><p>第二点主要做了以下操作：</p><ul><li>将成员变量 refreshed 设为 true。</li><li>为 DefaultListableBeanFactory 指定一个用于序列化的id。</li></ul><p>第三点主要做了以下操作：</p><ul><li>配置工厂的标准上下文特征，例如上下文的类加载器和后置处理程序。</li><li>所有bean定义都已加载，但还没有实例化bean。</li></ul><p>第四点主要做了以下操作：</p><ul><li>注册特定应用上下文的后置处理器bean</li><li>扫描basePackage指定的包路径</li><li>注册被注解的类，例如@Configuration</li></ul><p>第五点主要做了以下操作：</p><ul><li>实例化并调用所有已注册的BeanFactoryPostProcessor bean，如果给定显式顺序，则遵循显式顺序</li><li>分别调用实现了BeanFactoryPostProcessor接口的bean。</li></ul><p>第六点主要做了以下操作：</p><ul><li>实例化并调用所有已注册的BeanPostProcessor bean，如果给定显式顺序，则遵循显式顺序</li><li>分别调用实现了BeanPostProcessor接口的bean。</li></ul><p>第九点主要做了以下操作：</p><ul><li>默认创建TomcatWebServer</li><li>初始化WebApplicationContext和SerlvetContext参数</li></ul><p>第十一点完成BeanFactory的初始化并实例化剩余的单例bean：</p><p>finishBeanFactoryInitialization方法实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">// 初始化用于此上下文的转换服务</span><br><span class="line">if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果没有内嵌value解析器Bean则注册一个(例如 PropertyPlaceholderConfigurer bean)，主要用于解析$&#123;&#125;占位符.</span><br><span class="line">if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尽早地初始化LoadTimeWeaverAware bean以允许尽早地注册其变换器</span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止正用于类型匹配的临时类加载器</span><br><span class="line">beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">// 缓存所有bean定义的元数据，不接受后面的改变</span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">// 实例化所有剩余的（非懒加载）单例bean</span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中重点看最后一步preInstantiateSingletons方法的实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">// 迭代一个beanDefinitionNames的副本以允许init方法，这些方法又轮流注册新的bean定义。</span><br><span class="line">// 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。</span><br><span class="line">List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">// 触发所有非懒加载单例bean的初始化...</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">// 如果不是抽象的bean并且是非懒加载的单例bean，则进行</span><br><span class="line">if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">    // 判断是否是FactoryBean，如果是则进一步判断是否需要尽早的初始化bean，否则直接初始化bean</span><br><span class="line">if (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">if (bean instanceof FactoryBean) &#123;</span><br><span class="line">final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">boolean isEagerInit;</span><br><span class="line">if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line">if (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 触发所有可用单例bean的afterSingletonsInstantiated方法回调...</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line">if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">if (System.getSecurityManager() != null) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">return null;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来看getBean(beanName)方法的底层实现，是直接调用doGetBean方法，返回指定bean的实例，该实例可以是共享的或独立的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">       // 1. 返回bean名称，必要时删除工厂前缀，并将别名解析为规范名称。</span><br><span class="line">final String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line">// 2. 急切地检查单例缓存以手动地注册单例</span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line">if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">    // 3. 判断该当前bean是否在创建中</span><br><span class="line">if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</span><br><span class="line">&quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">logger.trace(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 4. 获取给定bean实例的对象，如果是FactoryBean，则为bean实例本身或其创建的对象。</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">    // 其它情况暂不做深入研究，感兴趣的读者可以自行阅读AbstractBeanFactory#doGetBean方法源码</span><br><span class="line">    ......</span><br><span class="line">       &#125;</span><br><span class="line">return (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看第二点getSingleton方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   @Nullable</span><br><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">// 如果从singletonObjects单例bean缓存中获取key为beanName的单例bean为空并且该单例bean</span><br><span class="line">// 当前在创建中（在整个工厂内）则从早期已实例化的单例bean缓存earlySingletonObjects中</span><br><span class="line">// 检查beanName的单例对象，如果为空则进一步从singletonFactories单例工厂缓存中获取beanName为key</span><br><span class="line">// 的BeanFactory，如果BeanFactory不为空则获取到其管理的单例bean实例并将其缓存</span><br><span class="line">// 到earlySingletonObjects对象上，最后从singletonFactories缓存中移除管理该beanName</span><br><span class="line">// 实例的BeanFactory对象（解决循环引用）</span><br><span class="line">if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">synchronized (this.singletonObjects) &#123;</span><br><span class="line">singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">if (singletonFactory != null) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">this.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要对象说明：</p><ul><li>singletonObjects：单例bean对象的缓存，ConcurrentHashMap-&gt;{beanName:beanInstance}</li><li>earlySingletonObjects: 早期的单例bean对象的缓存，HashMap-&gt;{beanName:beanInstance}</li><li>singletonFactories：单例BeanFactory的缓存，HashMap-&gt;{beanName:beanFactory}, beanFactory-&gt;beanInstance</li></ul><p>查看第四点getObjectForBeanInstance方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   protected Object getObjectForBeanInstance(</span><br><span class="line">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">// bean的name如果以&amp;开头，则是FactoryBean实例</span><br><span class="line">if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">// 验证是否是FactoryBean对象，不是则抛出异常</span><br><span class="line">if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回.</span><br><span class="line">if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = null;</span><br><span class="line">if (mbd == null) &#123;</span><br><span class="line">    // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">// beanInstance强转为FactoryBean</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">// 如果是单例，则缓存从FactoryBean获取的对象</span><br><span class="line">if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">// 最终调用FactoryBean实例的getObject方法获取bean实例</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到refresh方法的第十二点，最后完成上下文的刷新操作，调用LifecycleProcessor的onRefresh方法并且发布最终的ContextRefreshedEvent事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   protected void finishRefresh() &#123;</span><br><span class="line">// 清除此资源加载器中的所有资源缓存。</span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line">// 初始化此上下文的生命周期处理器DefaultLifecycleProcessor。</span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">// 调用DefaultLifecycleProcessor的onRefresh方法</span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">// 发布最终的ContextRefreshedEvent事件</span><br><span class="line">publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line"></span><br><span class="line">// 如果激活则参与到LiveBeansView MBean中</span><br><span class="line">LiveBeansView.registerApplicationContext(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类finishRefresh方法最后启动相应的WebServer并发布事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">protected void finishRefresh() &#123;</span><br><span class="line">super.finishRefresh();</span><br><span class="line">WebServer webServer = startWebServer();</span><br><span class="line">if (webServer != null) &#123;</span><br><span class="line">publishEvent(new ServletWebServerInitializedEvent(webServer, this));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<strong>Spring Boot启动流程源码分析</strong>的完整内容，如果有问题欢迎提出！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;版本：2.1.1.RELEASE&lt;/p&gt;&lt;p&gt;使用main方法启动Spring Boot应用：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://yidasanqian.github.io/categories/Spring-Boot/"/>
    
    
      <category term="源码分析" scheme="https://yidasanqian.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="doGetBean" scheme="https://yidasanqian.github.io/tags/doGetBean/"/>
    
      <category term="refreshContext" scheme="https://yidasanqian.github.io/tags/refreshContext/"/>
    
      <category term="refresh" scheme="https://yidasanqian.github.io/tags/refresh/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq Network Partitions 网络分区解决方案</title>
    <link href="https://yidasanqian.github.io/2019/04/04/Rabbitmq-Network-Partitions-%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://yidasanqian.github.io/2019/04/04/Rabbitmq-Network-Partitions-网络分区解决方案/</id>
    <published>2019-04-04T02:44:00.241Z</published>
    <updated>2019-04-08T01:48:17.519Z</updated>
    
    <content type="html"><![CDATA[<p>高可用集群环境（镜像模式）：</p><p>双节点：<br>rabbit@rabbit1（master）、rabbit@rabbit2（slave）</p><p>集群设置：</p><p>rabbit1控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p></p><p>将节点2加入到集群，rabbit2控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@rabbit1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p></p><blockquote><p>参数“—ram”表示设置为内存节点，忽略此参数则默认为磁盘节点。可以用命令<code>rabbitmqctl change_cluster_node_type disc</code><br>改变节点类型，需要注意的是集群环境中至少有一个为磁盘节点</p></blockquote><p>最后查看集群状态：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@rabbit2:/# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@rabbit2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@rabbit-cluster&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><p></p><p>首先解决网络分区导致队列不可用的问题，需要先设置队列的高可用策略，<br>在任意mq节点控制台执行命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy -p / ha-all &quot;^&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p></p><p>-p 指定vhost<br>“^” 指定策略匹配到所有队列</p><p>然后进入rabbit1控制台，编辑mq配置分区恢复处理策略：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@rabbit1:/# vim /etc/rabbitmq/rabbitmq.conf</span><br></pre></td></tr></table></figure><p></p><p>添加以下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 指定网络分区处理策略</span><br><span class="line">cluster_partition_handling = pause_if_all_down</span><br><span class="line"></span><br><span class="line">## Recovery strategy. Can be either &apos;autoheal&apos; or &apos;ignore&apos;</span><br><span class="line">cluster_partition_handling.pause_if_all_down.recover = autoheal</span><br><span class="line"></span><br><span class="line">## Node names to check</span><br><span class="line">cluster_partition_handling.pause_if_all_down.nodes.1 = rabbit@rabbit1</span><br><span class="line">cluster_partition_handling.pause_if_all_down.nodes.2 = rabbit@rabbit2</span><br></pre></td></tr></table></figure><p></p><p>RabbitMQ提供了4种处理网络分区的方式：</p><ol><li>ignore 默认，RabbitMQ不会自动做任何处理，即需要手动处理。</li><li>pause_minority 这种处理方式适合集群节点数大于2个且最好为奇数的情况，因为当网络恢复时，有可能两个节点会自动启动恢复网络分区，也有可能还是保持关闭状态。</li><li>pause_if_all_down, [nodes], ignore|autoheal RabbitMQ会自动关闭不能和[nodes]中节点通信的节点。</li><li>autoheal RabbitMQ会自动决定一个获胜的（winning）分区，然后重启不在这个分区中的节点以恢复网络分区。</li></ol><p>最后重启节点1，使策略生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高可用集群环境（镜像模式）：&lt;/p&gt;&lt;p&gt;双节点：&lt;br&gt;rabbit@rabbit1（master）、rabbit@rabbit2（slave）&lt;/p&gt;&lt;p&gt;集群设置：&lt;/p&gt;&lt;p&gt;rabbit1控制台：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://yidasanqian.github.io/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://yidasanqian.github.io/tags/RabbitMQ/"/>
    
      <category term="Network Partitions" scheme="https://yidasanqian.github.io/tags/Network-Partitions/"/>
    
      <category term="网络分区" scheme="https://yidasanqian.github.io/tags/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://yidasanqian.github.io/2019/04/03/hello-hexo/"/>
    <id>https://yidasanqian.github.io/2019/04/03/hello-hexo/</id>
    <published>2019-04-03T10:44:32.637Z</published>
    <updated>2019-04-09T01:49:51.453Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==" title="https://hexo.io/">Hexo<i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">documentation<i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=" title="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fa fa-external-link"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==" title="https://github.com/hexojs/hexo/issues">GitHub<i class="fa fa-external-link"></i></span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s" title="https://hexo.io/docs/writing.html">Writing<i class="fa fa-external-link"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=" title="https://hexo.io/docs/server.html">Server<i class="fa fa-external-link"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s" title="https://hexo.io/docs/generating.html">Generating<i class="fa fa-external-link"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s" title="https://hexo.io/docs/deployment.html">Deployment<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9oZXhvLmlvLw==&quot; title=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/spa
      
    
    </summary>
    
      <category term="other" scheme="https://yidasanqian.github.io/categories/other/"/>
    
    
      <category term="hexo" scheme="https://yidasanqian.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
