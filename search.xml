<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis插件开发原理]]></title>
    <url>%2F2019%2F07%2F08%2FMybatis%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Mybatis插件说明MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)ParameterHandler (getParameterObject, setParameters)ResultSetHandler (handleResultSets, handleOutputParameters)StatementHandler (prepare, parameterize, batch, update, query)这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 的发行包中的源代码。 假设你想做的不仅仅是监控方法的调用，那么你应该很好的了解正在重写的方法的行为。 因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定了想要拦截的方法签名即可。123456789101112131415// ExamplePlugin.java@Intercepts(&#123;@Signature( type= Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125;@Intercepts注解表明该类是拦截器，参数是方法签名数组。@Signature注解是方法签名参数分别是：type，表示要拦截的接口类型method，表示拦截接口下的方法args，表示方法参数主要在intercept方法中编写插件逻辑，通过该方法的参数invocation，可以获取调用的方法名和参数对象。plugin方法主要是对目标对象的包装。setProperties方法会读取mybatis-config.xml插件配置中设置的属性。123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt; &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt;上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。推荐一款动态添加日期的插件dynamic-add-date是基于Mybatis插件原理开发的可以动态在Insert和Update Sql语句中添加日期列和对应的值的插件，并且支持批量插入和批量更新。详细介绍可以进入以上链接。参考http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis-plugin</tag>
        <tag>Intercepts注解</tag>
        <tag>Signature注解</tag>
        <tag>Interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java并发编程的艺术》读书笔记（终章）]]></title>
    <url>%2F2019%2F07%2F01%2F%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BB%88%E7%AB%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记内容包含第九章～第十章线程池Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。线程池的实现原理当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？ 来看一下Jdk8中线程池的主要处理流程，处理流程图如下图所示：图源：java8线程池。如果运行的线程小于corePoolSize，则尝试以给定的命令(Runnable command)作为其第一个任务启动一个新线程。对addWorker方法的调用以原子地检查runState和workerCount，从而通过返回false，可以防止在不应该添加线程时发生错误警报。如果任务可以成功排队，那么我们仍然需要双重检查（double-check）是否应该添加一个线程（因为自上次检查后现有的线程已经死亡）或者自从进入此方法后池关闭了。所以我们重新检查状态，如果线程池状态停止并且任务从队列移除的话，拒绝该任务，如果没有，则启动新的线程。如果我们不能排队任务，那么我们尝试添加一个新线程。 如果失败，我们知道线程池已关闭或饱和，因此拒绝该任务。Note: 由于书上这部分的介绍对Jdk8来说已过时，上面笔者截取自Jdk8的ThreadPoolExecutor的execute方法的注释。线程池的使用Java线程池的创建1ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue RejectedExecutionHandler handler)参数解释：corePoolSize: 线程池维护线程的最少线程数,也是核心线程数,包括空闲线程maximumPoolSize: 线程池维护线程的最大线程数。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。keepAliveTime: 线程池维护线程所允许的空闲时间unit: 程池维护线程所允许的空闲时间的单位workQueue: 线程池所使用的缓冲队列/阻塞队列handler: 线程池对拒绝任务的处理策略当一个任务通过execute(Runnable)方法欲添加到线程池时：如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。如果此时线程池中的数量等于corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程 maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。可以选择以下几个阻塞队列:ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。PriorityBlockingQueue：一个具有优先级的无界阻塞队列。向线程池提交任务可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。区别:shutdownNow方法首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown方法只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。合理的配置线程池要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。任务的性质：CPU密集型任务、IO密集型任务和混合型任务。任务的优先级：高、中和低。任务的执行时间：长、中和短。任务的依赖性：是否依赖其他系统资源，如数据库连接。性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。作者举的例子：有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。执行器Executor框架包含的主要的类与接口如下图所示：下面是这些类和接口的简介。Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。Future接口和实现Future接口的FutureTask类，代表异步计算的结果。Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。ThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool.1）FixedThreadPool，下面是Executors提供的，创建使用固定线程数的FixedThreadPool的API。12public static ExecutorService newFixedThreadPool(int nThreads)public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。下面是newFixedThreadPool方法源码：12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;它是一种固定大小的线程池；corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉；阻塞队列采用了LinkedBlockingQueue，它是一个无界队列；由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。2) SingleThreadExecutor，下面是Executors提供的，创建使用单个线程的SingleThreadExecutor的API。12public static ExecutorService newSingleThreadExecutor()public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。下面是newSingleThreadExecutor方法源码：123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;它只会创建一条工作线程处理任务；其它作用与FixedThreadPool相同；3）CachedThreadPool，下面是Executors提供的，创建一个会根据需要创建新线程的CachedThreadPool的API。12public static ExecutorService newCachedThreadPool()public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。下面是newCachedThreadPool方法源码：12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;它是一个可以无限扩大的线程池；它比较适合处理执行时间比较小的任务；corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大；keepAliveTime为60s，意味着线程空闲时间超过60s就会被杀死；采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。在步骤2）中新创建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒钟。如果60秒钟内主线程提交了一个新任务（主线程执行步骤1）），那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止，因此长时间保持空闲的CachedThreadPool不会使用任何资源。总结：FixedThreadPool和SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列。CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。ScheduledThreadPoolExecutor通常使用工厂类Executors来创建。Executors可以创建2种类型的ScheduledThreadPoolExecutor，如下：1）ScheduledThreadPoolExecutor: 包含若干个线程的ScheduledThreadPoolExecutor。下面是工厂类Executors提供的，创建固定个数线程的ScheduledThreadPoolExecutor的API。12public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。2）SingleThreadScheduledExecutor: 只包含一个线程的ScheduledThreadPoolExecutor。下面是Executors提供的，创建单个线程的SingleThreadScheduledExecutor的API。12public static ScheduledExecutorService newSingleThreadScheduledExecutor()public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。ScheduledThreadPoolExecutor的执行主要分为两大部分。当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayedWorkQueue添加一个实现了RunnableScheduledFuture接口的ScheduledFutureTask对象。线程池中的线程从DelayedWorkQueue中获取ScheduledFutureTask，然后执行任务。scheduleAtFixedRate方法源码：123456789101112131415161718public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); if (period &lt;= 0) throw new IllegalArgumentException(); ScheduledFutureTask&lt;Void&gt; sft = new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(initialDelay, unit), unit.toNanos(period)); RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft); sft.outerTask = t; delayedExecute(t); return t;&#125;在ScheduledThreadPoolExecutor类中的ScheduledFutureTask待调度任务对象主要包含3个成员变量：123private final long sequenceNumber; // 表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。private long time; // 表示这个任务将要被执行的具体时间，单位：纳秒。private final long period; // 表示任务执行的间隔周期。DelayedWorkQueue是一个在ScheduledThreadPoolExecutor类中实现BlockingQueue接口的无界阻塞队列，所以ThreadPoolExecutor的maximumPoolSize在ScheduledThreadPoolExecutor中没有什么意义（设置maximumPoolSize的大小没有什么效果）。Note: 由于书中介绍的DelayQueue无界阻塞队列在Jdk8中不再是ScheduledThreadPoolExecutor的默认实现，所以这里说明改为DelayedWorkQueue，如果有误欢迎指出。Future当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个实现Future接口的对象。下面是对应的API:123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);Future&lt;?&gt; submit(Runnable task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Note: 由于书上这部分的介绍对Jdk8来说已过时，以下是笔者的总结：FutureTask可以处于下面几种状态：1234567private static final int NEW = 0; // 任务初始化，未运行private static final int COMPLETING = 1; // 任务正在运行private static final int NORMAL = 2; // 任务已运行完成private static final int EXCEPTIONAL = 3; // 任务运行异常private static final int CANCELLED = 4; // 任务被取消private static final int INTERRUPTING = 5; // 任务正在被中断private static final int INTERRUPTED = 6; // 任务已中断可能的状态转换：NEW -&gt; COMPLETING -&gt; NORMALNEW -&gt; COMPLETING -&gt; EXCEPTIONALNEW -&gt; CANCELLEDNEW -&gt; INTERRUPTING -&gt; INTERRUPTED图源：FutureTask解析Runnable接口和Callable接口Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果，而Callable可以返回结果。除了可以自己创建实现Callable接口的对象外，还可以使用工厂类Executors来把一个Runnable包装成一个Callable。下面是Executors提供的，把一个Runnable包装成一个Callable的API：12public static Callable&lt;Object&gt; callable(Runnable task)public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
        <tag>ThreadPoolExecutor</tag>
        <tag>Executors</tag>
        <tag>阻塞队列</tag>
        <tag>执行器</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java并发编程的艺术》读书笔记（三）]]></title>
    <url>%2F2019%2F06%2F28%2F%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记内容包含第七章～第八章原子操作类Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。因为变量的类型有很多种，所以在Atomic包里一共提供了12个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。原子更新基本类型类使用原子的方式更新基本类型，Atomic包提供了以下3个类：AtomicBoolean：原子更新布尔类型。AtomicInteger：原子更新整型。AtomicLong：原子更新长整型。Atomic包提供了3种基本类型的原子更新，但是Java的基本类型里还有char、float和double等。那么问题来了，如何原子的更新其他的基本类型呢？Atomic包里的类基本都是使用Unsafe实现的，Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong，再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似的思路来实现。原子更新数组通过原子的方式更新数组里的某个元素，Atomic包提供了以下3个类：AtomicIntegerArray：原子更新整型数组里的元素。AtomicLongArray：原子更新长整型数组里的元素。AtomicReferenceArray：原子更新引用类型数组里的元素。原子更新引用如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类，Atomic包提供了以下3个类：AtomicReference：原子更新引用类型。AtomicReferenceFieldUpdater：原子更新引用类型里的字段。AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。原子更新字段如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。AtomicLongFieldUpdater：原子更新长整型字段的更新器。AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。并发工具类在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段。CountDownLatchCountDownLatch允许一个或多个线程等待其他线程完成操作。CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。可用于要实现主线程等待所有子线程完成操作的场景。CyclicBarrierCyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。CyclicBarrier和CountDownLatch的区别CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。SemaphoreSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。理解Semaphore所表达的含义，把它比作是控制流量的红绿灯：比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路。但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。Semaphore可以用于做流量控制的场景，特别是公用资源有限的应用场景，比如数据库连接。1private static Semaphore s = new Semaphore(10);Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。ExchangerExchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
        <tag>并发</tag>
        <tag>atomic</tag>
        <tag>原子操作类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java并发编程的艺术》读书笔记（二）]]></title>
    <url>%2F2019%2F06%2F25%2F%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记内容包含第四章～第六章线程简介Java线程状态变迁由上图中可以看到，线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。Daemon线程Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。注意: Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。理解中断中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep(longmillis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。12345678public static final void second(long seconds) &#123; try &#123; TimeUnit.SECONDS.sleep(seconds); &#125; catch (InterruptedException e) &#123; // 抛出InterruptedException之前会清除中断标识位 System.out.println(&quot;throws intercepted exception&quot;); &#125;&#125;过期的suspend()、resume()和stop()方法不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法，而暂停和恢复操作可以用后面提到的等待/通知机制来替代。优雅的关闭线程123456789101112131415161718192021222324252627282930313233343536public class Shutdown &#123; public static void main(String[] args) throws Exception &#123; Runner one = new Runner(); Thread countThread = new Thread(one, &quot;CountThread&quot;); countThread.start(); // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束 TimeUnit.SECONDS.sleep(1); countThread.interrupt(); System.out.println(&quot;Count Thread isInterrupted: &quot; + countThread.isInterrupted()); Runner two = new Runner(); countThread = new Thread(two, &quot;CountThread&quot;); countThread.start(); // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束 TimeUnit.SECONDS.sleep(1); two.cancel(); System.out.println(&quot;Count Thread isInterrupted: &quot; + countThread.isInterrupted()); &#125; private static class Runner implements Runnable &#123; private long i; private volatile boolean on = true; @Override public void run() &#123; while (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; i++; &#125; System.out.println(&quot;Count i = &quot; + i); &#125; public void cancel() &#123; on = false; &#125; &#125;&#125;示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。线程间通讯Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。等待/通知机制，是指一个线程A调用了对象obj的wait()方法进入等待状态，而另一个线程B调用了对象obj的notify()或者notifyAll()方法，线程A收到通知后从对象obj的wait()方法返回，进而执行后续操作。上述两个线程通过对象obj来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。Java中的锁Lock接口Lock的使用的方式：1234567Lock lock = new ReentrantLock();lock.lock();try &#123; ...&#125; finally &#123; lock.unlock();&#125;在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。同步器 AbstractQueuedSynchronizer同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。独占式同步状态获取和释放过程总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。重入锁 ReentrantLock顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。这里提到一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。读写锁排他锁（如ReentrantLock），这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是ReentrantReadWriteLock。写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。锁降级锁降级指的是写锁降级成为读锁。锁降级是指当前拥有写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。并发容器和框架ConcurrentHashMapConcurrentHashMap是线程安全且高效的HashMap。在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。（1）线程不安全的HashMap在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。（2）效率低下的HashTableHashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。ConcurrentLinkedQueue实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法（即CAS算法）来实现，该算法在Michael&amp;Scott算法上进行了一些修改。阻塞队列阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。JDK 7提供了7个阻塞队列，如下：ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。LinkedBlockingQueue：一个由链表结构组成的无界阻塞队列。PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。DelayQueue：一个使用优先级队列实现的无界阻塞队列。SynchronousQueue：一个不存储元素的阻塞队列。LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。Fork/Join框架Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。图源：聊聊并发（八）——Fork/Join 框架介绍工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。优点：充分利用线程进行并行计算，减少了线程间的竞争。缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。图源：图解 Fork/Join以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
        <tag>并发</tag>
        <tag>线程状态</tag>
        <tag>Daemon线程</tag>
        <tag>线程中断</tag>
        <tag>关闭线程</tag>
        <tag>线程通讯</tag>
        <tag>重入锁</tag>
        <tag>读写锁</tag>
        <tag>通知模式</tag>
        <tag>并发容器</tag>
        <tag>Fork/Join框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java并发编程的艺术》读书笔记（一）]]></title>
    <url>%2F2019%2F06%2F14%2F%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记内容包含第一章～第三章上下文CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。上下文切换也会影响多线程的执行速度。dump线程信息里WAITING(on object monitor)的线程少了，系统上下文切换的次数就会少，因为每一次从WAITTING到RUNNABLE都会进行一次上下文的切换。死锁避免死锁的常见方法避免一个线程同时获取多个锁。避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。volatile在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。volatile的两条实现原则Lock前缀指令会引起处理器缓存回写到内存一个处理器的缓存回写到内存会导致其他处理器的缓存无效synchronizedsynchronized实现同步的基础，Java中的每一个对象都可以作为锁：对于普通同步方法，锁是当前实例对象。对于静态同步方法，锁是当前类的Class对象。对于同步方法块，锁是Synchonized括号里配置的对象。Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。synchronized用的锁是存在Java对象头里的。锁的升级与对比在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程：原子操作锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。CAS 即Compare And Swap通过锁实现原子操作：123456789101112Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (A) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;);使用循环CAS实现原子操作：123456789private void safeCount() &#123; for (;;) &#123; int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) &#123; break; &#125; &#125;&#125;CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题：ABA问题：如果一个值原来是A，变成了B，又变成了A。java.util.concurrent.atomic包里提供了一个类AtomicStampedReference来解决ABA问题。循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。只能保证一个共享变量的原子操作：java.util.concurrent.atomic.AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。Java内存模型（JMM）基础线程之间的通信机制有两种：共享内存: 线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。消息传递: 线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型：编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如下图所示：重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。顺序一致性JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性（Sequentially Consistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。顺序一致性内存模型有两大特性：一个线程中的所有操作必须按照程序的顺序来执行。（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（BusTransaction）。总线事务包括读事务（Read Transaction）和写事务（Write Transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写操作具有原子性。当JVM在这种处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。同步原语volatile锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。特性:可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。volatile写的内存语义如下：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。前文提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下表是JMM针对编译器制定的volatile重排序规则表：从上表我们可以看出：当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。对volatile写和volatile读的内存语义做个总结：线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替锁，请一定谨慎，具体详情请参阅Brian Goetz的文章《Java理论与实践：正确使用Volatile变量》。synchronized锁释放和锁获取的内存语义总结：线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。借助ReentrantLock类的源代码，来分析锁内存语义的具体实现机制。在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。ReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。使用公平锁时，加锁方法lock()调用轨迹如下：ReentrantLock:lock()FairSync:lock()AbstractQueuedSynchronizer:acquire(int arg)ReentrantLock:tryAcquire(int acquires)在第4步真正开始加锁，下面是该方法的源代码:12345678910111213141516171819protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); // 获取锁的开始，首先读volatile变量state if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125;从上面源代码中我们可以看出，加锁方法首先读volatile变量state。在使用公平锁时，解锁方法unlock()调用轨迹如下:ReentrantLock:unlock()AbstractQueuedSynchronizer:release(int arg)Sync:tryRelease(int releases)在第3步真正开始释放锁，下面是该方法的源代码:123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); // 释放锁的最后，写volatile变量state return free;&#125;从上面的源代码可以看出，在释放锁的最后写volatile变量state。非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下:ReentrantLock:lock()NonfairSync:lock()AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)在第3步真正开始加锁，下面是该方法的源代码:123protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;该方法以原子操作的方式更新state变量,JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。经过上面的分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。公平锁和非公平锁的内存语义总结:公平锁和非公平锁释放时，最后都要写一个volatile变量state。公平锁获取时，首先会去读volatile变量。非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。锁释放-获取的内存语义的实现至少有下面两种方式：利用volatile变量的写-读所具有的内存语义。利用CAS所附带的volatile读和volatile写的内存语义final只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出（escape）”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面的示例代码：12345678910111213141516171819public class FinalReferenceEscapeExample &#123; final int i; static FinalReferenceEscapeExample obj; public FinalReferenceEscapeExample() &#123; i = 1; // 1 写final域 obj = this; // 2 this引用在此&quot;逸出&quot; &#125; public static void writer() &#123; new FinalReferenceEscapeExample(); &#125; public static void reader() &#123; if (obj != null) &#123; // 3 int temp = obj.i; // 4 &#125; &#125;&#125;两个线程，线程a执行writer方法，由于操作1和2可能被重排序，当线程b执行reader方法时获取到的final域可能还是未初始化的。因此，在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。设计原理happens-before《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义：如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。happens-before关系本质上和as-if-serial语义是一回事，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。happens-before规则：程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。双重检查锁定与延迟初始化在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只在使用这些对象时才进行初始化。此时，可能会采用延迟初始化。但要正确实现线程安全的延迟初始化需要一些技巧，否则很容易出现问题。比如，下面是非线程安全的延迟初始化对象的示例代码：123456789101112public class UnsafeLazyInitialization &#123; private static Instance instance; public static Instance getInstance() &#123; if (instance == null) // 1：A线程执行 instance = new Instance(); // 2：B线程执行 return instance; &#125; static class Instance &#123; &#125;&#125;instance=new Singleton()创建了一个对象。这一行代码可以分解为如下的3行伪代码:123memory = allocate(); // 1：分配对象的内存空间ctorInstance(memory); // 2：初始化对象instance = memory; // 3：设置instance指向刚分配的内存地址上面3行伪代码中的2和3之间，可能会被重排序:123memory = allocate(); // 1：分配对象的内存空间instance = memory; // 3：设置instance指向刚分配的内存地址 注意，此时对象还没有被初始化！ctorInstance(memory); // 2：初始化对象上面3行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反Java语言规范里的intra-thread semantics。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。因此在UnsafeLazyInitialization类中，假设A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化，最终导致创建了多个对象实例。可以对getInstance()方法做同步处理来实现线程安全的延迟初始化。示例代码如下：123456789101112public class SafeLazyInitialization &#123; private static Instance instance; public synchronized static Instance getInstance() &#123; if (instance == null) instance = new Instance(); return instance; &#125; static class Instance &#123; &#125;&#125;由于对getInstance()方法做了同步处理，synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。反之，如果getInstance()方法不会被多个线程频繁的调用，那么这个延迟初始化方案将能提供令人满意的性能。在早期的JVM中，synchronized（甚至是无竞争的synchronized）存在巨大的性能开销。因此出现了双重检查锁定：123456789101112131415161718public class DoubleCheckedLocking &#123; //1 private static Instance instance; //2 public static Instance getInstance() &#123; //3 // 在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象 if (instance == null) &#123; //4:第一次检查 // 多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。 synchronized (DoubleCheckedLocking.class) &#123; //5:加锁 if (instance == null) //6:第二次检查 instance = new Instance(); //7:问题的根源出在这里 &#125; //8 &#125; //9 return instance; //10 &#125; //11 static class Instance &#123; &#125;&#125;如上面代码所示，如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此，可以大幅降低synchronized带来的性能开销。前面提到线程A执行到第7步代码可能会发生重排序。如果发生重排序，另一个并发执行的线程B就有可能在第4步判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。下图是这个场景的具体执行时序：这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象，因此可能会导致线程安全问题。可以看这个帖子加强理解。有两个办法来实现线程安全的延迟初始化：不允许A2和A3重排序 — 基于volatile的解决方案允许A2和A3重排序，但不允许其他线程“看到”这个重排序 — 基于类初始化的解决方案基于volatile的解决方案把instance声明为volatile型，就可以实现线程安全的延迟初始化。请看下面的示例代码：12345678910111213141516public class SafeDoubleCheckedLocking &#123; private volatile static Instance instance; public static Instance getInstance() &#123; if (instance == null) &#123; synchronized (SafeDoubleCheckedLocking.class) &#123; if (instance == null) instance = new Instance(); // instance为volatile，现在没问题了 &#125; &#125; return instance; &#125; static class Instance &#123; &#125;&#125;当声明对象的引用为volatile后，上面的3行伪代码中的2和3之间的重排序，在多线程环境中将会被禁止。基于类初始化的解决方案JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化。基于这个特性，可以实现另一种线程安全的延迟初始化方案（这个方案被称之为Initialization On Demand Holder idiom）：123456789101112public class InstanceFactory &#123; private static class InstanceHolder &#123; public static Instance instance = new Instance(); &#125; public static Instance getInstance() &#123; return InstanceHolder.instance; // 这里将导致InstanceHolder类被初始化 &#125; static class Instance &#123; &#125;&#125;Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。通过对比基于volatile的双重检查锁定的方案和基于类初始化的方案，我们会发现基于类初始化的方案的实现代码更简洁。但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
        <tag>并发</tag>
        <tag>volatile</tag>
        <tag>synchronized</tag>
        <tag>锁</tag>
        <tag>CAS</tag>
        <tag>final</tag>
        <tag>内存语义</tag>
        <tag>Java内存模型</tag>
        <tag>JMM</tag>
        <tag>重排序</tag>
        <tag>happens-before</tag>
        <tag>延迟初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot中使用Elasticsearch联合查询]]></title>
    <url>%2F2019%2F05%2F29%2FSpring-boot%E4%B8%AD%E4%BD%BF%E7%94%A8Elasticsearch%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[加入Elasticsearch依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt;在application.yml文件配置Elasticsearch：123456spring: elasticsearch: rest: uris: es节点1,es节点2 username: 用户名 password: 密码推荐使用这种方式。然后就可以使用下面的代码自动装配Elasticsearch的高级版客户端：12@Autowiredprivate RestHighLevelClient restHighLevelClient;下面举例如何使用bool联合查询：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static final String DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;;public List&lt;MsgStateDTO&gt; queryMsgStateLogFromElasticsearch(String appId, String messageId, String receiver) &#123; // 使用bool联合查询需要用到BoolQueryBuilder这个构建器，must方法表示完全匹配 BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery() .must(QueryBuilders.termQuery(&quot;appId&quot;, appId)); if (!StringUtils.isEmpty(messageId)) &#123; boolQueryBuilder.must(QueryBuilders.termQuery(&quot;messageId&quot;, messageId)); &#125; if (!StringUtils.isEmpty(receiver)) &#123; boolQueryBuilder.must(QueryBuilders.termQuery(&quot;receiver&quot;, receiver)); &#125; // 这里使用RangeQueryBuilder进行日期范围查询，‘createTime’是MsgStateDTO类的属性。 // 这里表示查询到此为止3个月前的数据。 RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery(&quot;createTime.keyword&quot;) .format(DATETIME_FORMAT) .timeZone(&quot;+08:00&quot;) .from(LocalDateTime.now().minusMonths(3).format(DateTimeFormatter.ofPattern(DATETIME_FORMAT))) .to(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATETIME_FORMAT))); // 添加过滤条件 boolQueryBuilder.filter(rangeQueryBuilder); // 构建完整的查询语句，SearchSourceBuilder构建表示从第0页开始查询10条，并根据@timestamp字段倒序，然后超时10s SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder() .query(boolQueryBuilder) .size(10) .sort(new FieldSortBuilder(&quot;@timestamp&quot;).order(SortOrder.DESC)) .timeout(new TimeValue(10, TimeUnit.SECONDS)); SearchRequest searchRequest = new SearchRequest(); // 指定日志所在的索引 searchRequest.indices(INDICES_CSP_MSG_STATE); searchRequest.source(searchSourceBuilder); log.info(&quot;执行Elasticsearch查询：&#123;&#125;&quot;, searchSourceBuilder); List&lt;MsgStateDTO&gt; msgStateDTOList = Collections.emptyList(); try &#123; // 执行查询 SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT); // 结果映射 SearchHit[] hits = searchResponse.getHits().getHits(); Set&lt;MsgStateDTO&gt; msgStateDTOSet = new HashSet&lt;&gt;(); for (SearchHit hit : hits) &#123; MsgStateDTO msgStateDTO = $.json.toObject(hit.getSourceAsString(), MsgStateDTO.class); msgStateDTOSet.add(msgStateDTO); &#125; msgStateDTOList = msgStateDTOSet.stream() .sorted(Comparator.comparing(MsgStateDTO::getCreateAt).reversed()) .collect(Collectors.toList()); &#125; catch (IOException e) &#123; log.error(&quot;请求日志服务异常&quot;, e); throw new BusinessException(&quot;请求日志服务异常&quot;); &#125; return msgStateDTOList;&#125;注释写得比较详细了，不再进一步说明。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>BoolQueryBuilder</tag>
        <tag>RangeQueryBuilder</tag>
        <tag>RestHighLevelClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决由于设置Mybatis的BatchExecutor批量执行器而导致无法获取自增Id的问题]]></title>
    <url>%2F2019%2F05%2F22%2F%E8%A7%A3%E5%86%B3%E7%94%B1%E4%BA%8E%E8%AE%BE%E7%BD%AEMybatis%E7%9A%84BatchExecutor%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E5%99%A8%E8%80%8C%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9EId%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Mybatis中有三种Executor:SimpleExecutor — SIMPLE 就是普通的执行器。ReuseExecutor -执行器会重用预处理语句（prepared statements）BatchExecutor —它是批量执行器这些就是Mybatis的三种执行器。你可以通过配置文件的settings里面的元素defaultExecutorType，配置它，默认是采用SimpleExecutor如果你在Spring运用它，那么你可以这么配置它：12345&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;!--更新采用批量的executor --&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;BATCH&quot;/&gt; &lt;/bean&gt;或者在Spring Boot的属性文件中配置：1mybatis.executor-type=BATCH如果你在事务中有这么一段代码：123456789Media media = new Media();media.setTitle(&quot;默认用户头像&quot;);media.setMediaType(0);media.setUrl(defaultAvatarUrl);mediaMapper.insert(media);logger.info(&quot;mediaId : &quot; + media.getId());User user = new User();user.setMedia(media);userMapper.insert(user);那么就会导致Media无法获取插入数据库后的id。这是由于设置了executorType=BATCH而导致执行更新Sql时Mybatis没有提交语句到数据库。这时有两种解决方法：方法1：只需要修改Executor为其它两种SIMPLE or REUSE即可：1234&lt;bean id=&quot;sqlSessionTemplateBatch&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;SIMPLE&quot;/&gt; &lt;/bean&gt;或者在Spring Boot的属性文件中配置：1mybatis.executor-type=SIMPLE方法2:在insert方法之后执行：12// 刷新批量更新语句缓存，将Sql语句发送到数据库执行sqlSession.flushStatements();以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>SimpleExecutor</tag>
        <tag>ReuseExecutor</tag>
        <tag>BatchExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis执行Sql流程源码分析]]></title>
    <url>%2F2019%2F05%2F20%2FMybatis%E6%89%A7%E8%A1%8CSql%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[环境：1mybatis-spring-boot-starter: 1.3.4在MybatisAutoConfiguration类中查看Mybatis的SqlSessionFactory接口的实现DefaultSqlSessionFactory是如何注册到Spring容器的。由于不是本文重点，这里就不贴源码了，描述下大概流程：Mybatis是通过SqlSessionFactoryBean工厂bean的方式获取bean实例的。首先通过SqlSessionFactoryBean类的buildSqlSessionFactory方法中调用xmlMapperBuilder.parse()方法将Mapper接口的Class类型作为key，MapperProxyFactory实例作为value注册到MapperRegistry类上。然后将MapperRegistry实例设置到Configuration类的mapperRegistry属性上。最后调用SqlSessionFactoryBuilder类的build方法完成SqlSessionFactory实例的创建：123public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;这里看下MapperProxyFactory类的源码：1234567891011121314151617181920212223242526272829public class MapperProxyFactory&lt;T&gt; &#123; // Mapper接口的Class类型的引用 private final Class&lt;T&gt; mapperInterface; // Mapper接口中定义的方法 private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings(&quot;unchecked&quot;) protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125;可以看到通过调用MapperProxyFactory的newInstance方法完成Mapper接口代理的生成。这里用到了Jdk的动态代理。这里说明一点，Mybatis和Spring整合使用SqlSession的实现是SqlSessionTemplate，它是线程安全的由Spring管理的单例bean。当调用Mapper接口的方法时，实际上会调用MapperProxy代理的invoke方法：123456789101112131415@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (isDefaultMethod(method)) &#123; return invokeDefaultMethod(proxy, method, args); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; // 缓存Mapper接口的方法 final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args);&#125;然后返回调用MapperMethod类的execute方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; switch (command.getType()) &#123; case INSERT: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); break; &#125; case UPDATE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); break; &#125; case DELETE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); break; &#125; case SELECT: if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; result = executeForMap(sqlSession, args); &#125; else if (method.returnsCursor()) &#123; result = executeForCursor(sqlSession, args); &#125; else &#123; Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); &#125; break; case FLUSH: result = sqlSession.flushStatements(); break; default: throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;); &#125; return result; &#125;可以看到这里通过命令模式处理对应的Sql。这里笔者选择执行一条查询命令，那么最终会调用该类的executeForMany方法：123456789101112131415161718192021private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) &#123; List&lt;E&gt; result; // 根据命名规则获取参数映射对象ParamMap Object param = method.convertArgsToSqlCommandParam(args); // 判断方法上是否有RowBounds参数，如果有则Sql语句加上 offset,limit if (method.hasRowBounds()) &#123; RowBounds rowBounds = method.extractRowBounds(args); result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds); &#125; else &#123; result = sqlSession.&lt;E&gt;selectList(command.getName(), param); &#125; // issue #510 Collections &amp; arrays support if (!method.getReturnType().isAssignableFrom(result.getClass())) &#123; if (method.getReturnType().isArray()) &#123; return convertToArray(result); &#125; else &#123; return convertToDeclaredCollection(sqlSession.getConfiguration(), result); &#125; &#125; return result;&#125;接下来进入SqlSessionTemplate的selectList方法：1234@Overridepublic &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);&#125;可以看到其实是调用的SqlSession的代理来调用实际的selectList方法。查看SqlSessionTemplate类的构造方法的源码有这一行：123this.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());可知SqlSessionTemplate持有SqlSession接口的代理，其默认实现是DefaultSqlSession。查看该类的selectList方法实现：123456789101112@Overridepublic &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; // statement是Mapper接口的方法的完全限定名，这里获取对应的映射信息 MappedStatement ms = configuration.getMappedStatement(statement); return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(&quot;Error querying database. Cause: &quot; + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125;由于Mybatis默认是打开本地缓存的，即每个Session都持有Executor的引用实现CachingExecutor。接下来进入CachingExecutor的query方法：12345678@Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; // 获取绑定的sql对象 BoundSql boundSql = ms.getBoundSql(parameterObject); // 创建缓存key CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); &#125;进入BaseExecutor的query方法实现，有这么一行：1list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);继续查看queryFromDatabase方法实现，有这么一行：1list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);由于默认使用Mybatis的ExecutorType是SIMPLE，所以进入SimpleExecutor的doQuery方法实现：123456789101112131415@Override public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 1. 根据映射语句执行插件来拦截的方法调用 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 2. 预编译语句 stmt = prepareStatement(handler, ms.getStatementLog()); // 3. 执行查询 return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125; &#125;第一点，查看实现会返回RoutingStatementHandler实例，由于默认的语句类型是StatementType.PREPARED，所以该类持有PreparedStatementHandler对象的引用。第二点，prepareStatement方法实现：12345678private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123; Statement stmt; Connection connection = getConnection(statementLog); stmt = handler.prepare(connection, transaction.getTimeout()); // 委托调用PreparedStatementHandler的parameterize方法进行参数设置 handler.parameterize(stmt); return stmt; &#125;PreparedStatementHandler的parameterize方法会调用DefaultParameterHandler的setParameters方法处理参数映射：12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void setParameters(PreparedStatement ps) &#123; ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId()); // 获取参数映射列表 List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings != null) &#123; // 遍历参数映射列表 for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; Object value; // 获取属性名 String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; value = parameterObject; &#125; else &#123; MetaObject metaObject = configuration.newMetaObject(parameterObject); // 根据属性名获取属性值 value = metaObject.getValue(propertyName); &#125; // 获取参数类型处理器，假定参数是int/integer类型那么最终typeHandler实例是IntegerTypeHandler TypeHandler typeHandler = parameterMapping.getTypeHandler(); // 获取参数Jdbc类型 JdbcType jdbcType = parameterMapping.getJdbcType(); if (value == null &amp;&amp; jdbcType == null) &#123; jdbcType = configuration.getJdbcTypeForNull(); &#125; try &#123; // 设置参数，如果参数不为空最终会调用IntegerTypeHandler的setNonNullParameter方法设置对应参数值 typeHandler.setParameter(ps, i + 1, value, jdbcType); &#125; catch (TypeException e) &#123; throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e); &#125; catch (SQLException e) &#123; throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e); &#125; &#125; &#125; &#125;&#125;第三点，委托调用PreparedStatementHandler的query方法：12345678@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; // 执行语句 ps.execute(); // 处理结果并返回，唯一实现是DefaultResultSetHandler return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125;这里重点看下结果的映射，结果的类型处理和参数的类型处理都是基于TypeHandler接口的实现，可以看看其抽象类的实现BaseTypeHandler：1234567891011121314@Overridepublic T getResult(ResultSet rs, String columnName) throws SQLException &#123; T result; try &#123; result = getNullableResult(rs, columnName); &#125; catch (Exception e) &#123; throw new ResultMapException(&quot;Error attempting to get column &apos;&quot; + columnName + &quot;&apos; from result set. Cause: &quot; + e, e); &#125; if (rs.wasNull()) &#123; return null; &#125; else &#123; return result; &#125;&#125;这里getNullableResult方法是抽象方法，将由具体的子类实现。比如有个实体的属性是1private LocalDateTime createAt;那么将会使用LocalDateTimeTypeHandler类的实现，也可以指定自己的TypeHandler实现，在&lt;resultMap&gt;标签的子标签&lt;result&gt;自定义typeHandler：1&lt;result property=&quot;createAt&quot; column=&quot;create_at&quot; typeHandler=&quot;org.apache.ibatis.type.LocalDateTimeTypeHandler&quot;/&gt;到此，Mybatis的调用流程源码分析结束。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>MapperProxy</tag>
        <tag>SqlSessionFactory</tag>
        <tag>TypeHandler</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring WebMVC请求处理流程源码分析]]></title>
    <url>%2F2019%2F05%2F07%2FSpring-WebMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Spring WebMVC 版本：5.1.3.RELEASE定义一个controller12345678910111213@RequestMapping(&quot;dingtalk&quot;)@RestControllerpublic class DingtalkController &#123; @Autowired private DingTalkService dingTalkService; @GetMapping(value = &quot;contact/authscope&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE ) public Object findContactAuthScope() &#123; dingTalkService.getContactAuthScope(dingTalkService.getAccessToken()); return HttpStatus.OK; &#125;&#125;我们请求http://localhost:9000/dingtalk/contact/authscope这个URL时会调用该controller的 findContactAuthScope 方法。那么Spring MVC是怎么实现这个处理流程的呢？图源：SpringMVC流程架构图我们知道 DispatcherServlet 类是Spring MVC 的入口，每次请求都会调用它的 doService 方法，该方法又将请求委托给 doDispatch 方法处理，我们来看doDispatch方法的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 1. 获取当前请求的HandlerExecutionChain，HandlerExecutionChain持有Handler对象和HandlerInterceptor， mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 2. 获取当前请求的Handler对应的HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 如果HandlerMethod支持，处理 last-modified 请求头. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); // 请求资源未改变则中断处理直接返回 if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 3. 通过HandlerAdapter调用具体的HandlerMethod来处理请求，最后返回ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; ...... // 视图解析和显示 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; ......&#125;第1点getHandler方法的实现：1234567891011121314 @Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; // 获取当前请求的拦截器列表和Handler对象 HandlerExecutionChain handler = mapping.getHandler(request); // 这里的mapping实例是RequestMappingHandlerMapping，通过 getHandler 方法获取到的hanlder不为空 if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125;RequestMappingHandlerMapping 类用于从@Controller注解所在的类的@RequestMapping注解上构建（RequestMappingInfo）请求映射信息实例。可以看到是通过遍历HandlerMapping列表，然后调用每个HandlerMapping接口的getHandler方法，进入实现该接口的抽象类 AbstractHandlerMapping 重写的getHandler方法实现：12345678910111213141516171819202122232425262728293031 @Override@Nullablepublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 查询当前请求的HandlerMethod Object handler = getHandlerInternal(request); // 当前请求的Handler如果为空则获取默认的HandlerMethod if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // 如果handler是bean name字符串则获取对应的bean实例 if (handler instanceof String) &#123; String handlerName = (String) handler; handler = obtainApplicationContext().getBean(handlerName); &#125; // 添加HandlerMethod和HandlerInterceptor拦截器到HandlerExecutionChain中，对应handler和interceptorList成员变量 HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); ...... // 如果请求头包含Origin则进行跨域配置 if (CorsUtils.isCorsRequest(request)) &#123; CorsConfiguration globalConfig = this.corsConfigurationSource.getCorsConfiguration(request); CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig); executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain;&#125;进入到AbstractHandlerMethodMapping的getHandlerInternal方法的实现：1234567891011121314 @Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; // 查询到请求uri为 /dingtalk/contact/authscope String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); this.mappingRegistry.acquireReadLock(); try &#123; // 根据查询到的路径查询当前请求对应的HandlerMethod HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); &#125; finally &#123; this.mappingRegistry.releaseReadLock(); &#125;&#125;到这里就查到请求的uri对应的是findContactAuthScope方法。下一步执行第2点，获取HandlerMethod对应的HandlerAdapter，查看getHandlerAdapter方法实现：123456789101112 protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; // 这里返回的是 RequestMappingHandlerAdapter 实例，继承AbstractHandlerMethodAdapter // 用于支持@RequestMapping注解的类和方法 if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; ......&#125;下一步执行第3点，调用 AbstractHandlerMethodAdapter的handle方法，最终会调用子类的handleInternal方法，该方法位于RequestMappingHandlerAdapter：1234567891011121314151617181920212223242526272829303132333435363738 @Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; // 检查给定的请求是否支持（request method）方法和所需（session）会话(如果有的话) checkRequest(request); // 如果需要会话同步则运行 invokeHandlerMethod 方法在同步代码块中 if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // 没有可用的 HttpSession -&gt; 不需要互斥锁 mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // 根本不需要会话同步 ... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125;invokeHandlerMethod方法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 @Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; // 调用controller的目标方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; // 返回ModelAndView return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125;在此方法中调用了invokeAndHandle方法，实现反射调用目标方法并通过 HandlerMethodReturnValueHandler 接口的实现类处理返回结果值，然后会调用实现了ResponseBodyAdvice 接口的类的beforeBodyWrite方法处理返回值，最后通过实现了GenericHttpMessageConverter 接口的类将响应body写入输出流信息中。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>DispatcherServlet</tag>
        <tag>HandlerMapping</tag>
        <tag>HandlerAdapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决SQLFeatureNotSupportedException异常]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%A7%A3%E5%86%B3SQLFeatureNotSupportedException%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[环境：12345jdk：1.8mybatis-spring-boot-starter：2.0.1druid-spring-boot-starter: 1.1.14mysql-connector-java: 5.1.47spring-boot-starter-parent: 2.1.4.RELEASE使用Mybatis查询时出现以下异常：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192org.springframework.dao.InvalidDataAccessApiUsageException: Error attempting to get column &apos;create_at&apos; from result set. Cause: java.sql.SQLFeatureNotSupportedException; null; nested exception is java.sql.SQLFeatureNotSupportedException at org.springframework.jdbc.support.SQLExceptionSubclassTranslator.doTranslate(SQLExceptionSubclassTranslator.java:96) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:73) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446) at com.sun.proxy.$Proxy68.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:147) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:80) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:58) at com.sun.proxy.$Proxy69.queryAllByLimit(Unknown Source) at io.github.yidasanqian.mybatisdemo.service.impl.RoleServiceImpl.queryAllByLimit(RoleServiceImpl.java:44) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) at com.sun.proxy.$Proxy72.queryAllByLimit(Unknown Source) at io.github.yidasanqian.mybatisdemo.MybatisDemoApplicationTests.testRoleQuery(MybatisDemoApplicationTests.java:45) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Caused by: java.sql.SQLFeatureNotSupportedException at com.alibaba.druid.pool.DruidPooledResultSet.getObject(DruidPooledResultSet.java:1771) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.ibatis.logging.jdbc.ResultSetLogger.invoke(ResultSetLogger.java:69) at com.sun.proxy.$Proxy94.getObject(Unknown Source) at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:38) at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:28) at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:81) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getPropertyMappingValue(DefaultResultSetHandler.java:472) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyPropertyMappings(DefaultResultSetHandler.java:441) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:404) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForSimpleResultMap(DefaultResultSetHandler.java:354) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:301) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:194) at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:65) at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:147) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) ... 51 moreMapper.xml:123456&lt;resultMap type=&quot;io.github.yidasanqian.mybatisdemo.entity.Role&quot; id=&quot;Role_ResultMap&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;createAt&quot; column=&quot;create_at&quot;/&gt; &lt;result property=&quot;updateAt&quot; column=&quot;update_at&quot;/&gt;&lt;/resultMap&gt;Role.java123456789public class Role implements Serializable &#123; private static final long serialVersionUID = -50780509322421020L; private Integer id; private String name; private LocalDateTime createAt; private LocalDateTime updateAt; // ignored getter &amp; setter&#125;原因是Druid不支持JDBC4.1及以上版本导致的，可以将mybatis-spring-boot-starter版本降为1.3.4即可解决。Druid 1.1.18 版本已解决此问题，详情看此issue：3194]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Druid</tag>
        <tag>LocalDateTimeTypeHandler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你如何让Mac定时自动开关黑暗模式]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E8%AE%A9Mac%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E5%BC%80%E5%85%B3%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[首先在Home目录下创建苹果脚本 ChangeDarkMode.applescript：12345tell application &quot;System Events&quot; tell appearance preferences set dark mode to not dark mode end tellend tell然后使用crontab -e新建定时任务,英文输入法下输入命令i进入编辑模式：120 22 * * * osascript ~/ChangeDarkMode.applescript12 9 * * * osascript ~/ChangeDarkMode.applescript第一行表示每天22:00 开启黑暗模式。第二行表示每天9:12，关闭黑暗模式。最后按esc退出编辑模式，并输入命令:wq保存退出。输入命令crontab -l可查看任务是否新建成功。需要注意的是如果Mac处于睡眠状态的话定时任务是不起作用的，此时需要手动开启或关闭黑暗模式！如果你的Mac安装了Alfred，那么可以使用切换外观模式工作流脚本来手动切换黑暗模式。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>DarkMode</tag>
        <tag>AppleScript</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory和FactoryBean接口的区别]]></title>
    <url>%2F2019%2F04%2F11%2FBeanFactory%E5%92%8CFactoryBean%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Spring版本：5.1.3.RELEASEBeanFactory接口：123456789101112131415String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;Object getBean(String name) throws BeansException;&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;Object getBean(String name, Object... args) throws BeansException;&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType);&lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType);boolean containsBean(String name);boolean isSingleton(String name) throws NoSuchBeanDefinitionException;boolean isPrototype(String name) throws NoSuchBeanDefinitionException;boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;String[] getAliases(String name);是简单工厂模式的应用，根据传入的beanName实例化相应的实例。JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）：用于访问Spring bean容器的根接口。 这是bean容器的基本客户端视图; 其他接口（如ListableBeanFactory和org.springframework.beans.factory.config.ConfigurableBeanFactory）可用于特定目的。该接口被一些持有bean定义的对象实现，每个bean定义由一个字符串名称唯一标识。根据bean定义，工厂将返回包含对象的独立实例（Prototype设计模式）或单个共享实例（Singleton设计模式的高级替代，其中实例是工厂范围中的单例）。将返回哪种类型的实例取决于bean工厂配置：API是相同的。从Spring 2.0开始，根据具体的应用程序上下文（例如Web环境中的“request”和“session”范围），可以使用更多的scope（范围）。这种方法的重点是BeanFactory是应用组件的注册中心和集中的配置中心（例如，不再需要单个对象去读取属性文件）。有关此方法的优点的讨论，请参见”Expert One-on-One J2EE Design and Development”的第4章和第11章。请注意，依靠依赖注入（“push”配置）通过setter或构造函数来配置应用对象通常更好,而不是像BeanFactory查找一样的使用“pull”配置的任意方式。Spring的依赖注入功能是使用这个BeanFactory接口及其子接口实现的。通常，BeanFactory将加载存储在配置源（例如XML文档）中的bean定义，并使用org.springframework.beans包来配置bean。尽管如此，一种简单地实现是直接在Java代码中返回Java对象。如何存储定义没有限制：LDAP，RDBMS，XML，属性文件等。鼓励实现支持bean之间的引用（依赖注入）。与ListableBeanFactory中的方法相反，如果这是HierarchicalBeanFactory，则此接口中的所有操作也将检查父工厂。如果在此工厂实例中找不到bean，则会询问直接父工厂（从父类bean工厂中获取）。此工厂实例中的Bean应该在任何父工厂中覆盖同名的Bean。Bean工厂实现应尽可能支持标准bean生命周期接口。 完整的初始化方法及其标准顺序是：BeanNameAware 接口的 setBeanName 方法BeanClassLoaderAware 接口的 setBeanClassLoader 方法BeanFactoryAware 接口的 setBeanFactory 方法EnvironmentAware 接口的 setEnvironment 方法EmbeddedValueResolverAware 接口的 setEmbeddedValueResolver 方法ResourceLoaderAware 接口的 setResourceLoader 方法 (仅适用于在应用程序上下文（Application Context）中运行时)ApplicationEventPublisherAware 接口的 setApplicationEventPublisher 方法 (仅适用于在应用程序上下文（Application Context）中运行时)MessageSourceAware 接口的 setMessageSource 方法 (仅适用于在应用程序上下文（Application Context）中运行时)ApplicationContextAware 接口的 setApplicationContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)ServletContextAware 接口的 setServletContext 方法 (仅适用于在应用程序上下文（Application Context）中运行时)所有实现了BeanPostProcessor接口的类的 postProcessBeforeInitialization 方法InitializingBean 接口的 afterPropertiesSet 方法自定义的init方法所有实现了BeanPostProcessor接口的类的 postProcessAfterInitialization 方法关闭Bean工厂时，应用以下生命周期方法:所有实现了DestructionAwareBeanPostProcessor接口的类的 postProcessBeforeDestruction 方法DisposableBean 接口的 destroy 方法自定义的destroy 方法Spring Bean生命周期图：Spring 4.3.17.RELEASE 源码的JavaDoc文档写的也是以上流程。跟其它网上的文章写的流程有出入，应该以官方文档为准。FactoryBean接口：12345T getObject() throws Exception;Class&lt;?&gt; getObjectType();default boolean isSingleton() &#123; return true;&#125;是工厂方法模式的应用，由子类实现相应的实例。JavaDoc翻译（使用Google翻译并加以润色，如有歧义欢迎指出）：接口被BeanFactory中使用的对象所实现，这些对象本身就是单个对象的工厂。如果bean实现了这个接口，它将被用作暴露此对象的工厂，而不是直接将自己作为bean实例给暴露出来。注意：实现此接口的bean不能用作普通bean。FactoryBean是被定义成bean的形式，但是bean对象的引用（getObject()方法获得）始终是由它创建的。FactoryBeans可以支持单例和原型，可以根据需要懒惰地创建对象，也可以在启动时急切地创建对象。SmartFactoryBean接口允许公开更细粒度的行为元数据。该接口在框架内部大量使用，例如用于AOP的 org.springframework.aop.framework.ProxyFactoryBean类 或 org.springframework.jndi.JndiObjectFactoryBean类。它也可以用于定制组件;但是，这仅适用于基础架构代码。FactoryBean是一个programatic contract (编程合约)。实现不应该依赖annotation-driven (注解驱动)的注入或其他反射设施。getObjectType()和getObject()方法的调用可能在引导过程的早期发生，甚至在所有的（post-processor）后置处理器设置之前。如果您需要访问其他bean，请实现 BeanFactoryAware 并以编程方式获取它们。最后，FactoryBean对象参与包含BeanFactory的bean创建的同步。除了FactoryBean本身（或类似）中的延迟初始化之外，通常不需要内部同步。下面从源码层面深入分析二者区别：查看 BeanFactory接口的抽象类 AbstractBeanFactory的getObjectForBeanInstance方法的实现：123456789101112131415161718192021222324252627282930313233343536 protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // bean的name如果以&amp;开头，则是FactoryBean实例 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; // 验证是否是FactoryBean对象，不是则抛出异常 if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; &#125; // 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回. if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // beanInstance强转为FactoryBean FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // 如果是单例，则缓存从FactoryBean获取的对象 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); // 最终调用FactoryBean实例的getObject方法获取bean实例 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125;在getObjectFromFactoryBean方法实现中会调用doGetObjectFromFactoryBean方法：123456789101112131415161718192021 private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName) throws BeanCreationException &#123; Object object; try &#123; if (System.getSecurityManager() != null) &#123; AccessControlContext acc = getAccessControlContext(); try &#123; // 调用FactoryBean的getObject方法来返回实例 object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc); &#125; ...... &#125; else &#123; // 调用FactoryBean的getObject方法来返回实例 object = factory.getObject(); &#125; &#125; ...... return object;&#125;实现FactoryBean的类,在初始化放入容器后,通过BeanFactory的getBean方法调用时,会调用FactoryBean的getObject方法返回对应的bean实例对象,而不是像普通的bean一样直接返回bean实例.BeanFactory的常量&amp;的作用是在获取bean的时候直接返回FactoryBean的bean实例,而不是调用的getObject方法返回对应的bean实例.以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>BeanFactory</tag>
        <tag>FactoryBean</tag>
        <tag>Bean生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Skipping MapperFactoryBean with name ‘xxxMapper' mapperInterface]]></title>
    <url>%2F2019%2F04%2F10%2FSkipping-MapperFactoryBean-with-name-%E2%80%98xxxMapper-mapperInterface%2F</url>
    <content type="text"><![CDATA[解决Spring Boot应用整合Mybatis启动输出警告日志：1[main] o.m.s.mapper.ClassPathMapperScanner - Skipping MapperFactoryBean with name &apos;channelMapper&apos; and &apos;io.github.yidasanqian.dao.ChannelMapper&apos; mapperInterface. Bean already defined with the same name!这是由于mybatis-spring-boot-starter 依赖的自动配置导致的：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;只需要在应用启动类加上注解 @MapperScan 即可，1234567@MapperScan(&#123;&quot;io.github.yidasanqian.dao&quot;&#125;)@SpringCloudApplicationpublic class ChannelApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ChannelApplication.class, args); &#125;&#125;重要的是要指定扫描的mapper接口包路径，上面表示扫描包为io.github.yidasanqian.dao下的所有mapper接口定义。以上，如有问题欢迎提出！]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>MapperFactoryBean</tag>
        <tag>MapperScan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot启动流程源码分析]]></title>
    <url>%2F2019%2F04%2F09%2FSpring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[版本：2.1.1.RELEASE使用main方法启动Spring Boot应用：123public static void main(String[] args) &#123; SpringApplication.run(DingtalkApplication.class, args);&#125;进入SpringApplication类的run方法最终实现位置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public ConfigurableApplicationContext run(String... args) &#123; // 1. 启动计时 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; // 2. 回调接口SpringBootExceptionReporter用于支持自定义spring应用程序启动错误的报告 Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 3. 配置启用Java headless模式 configureHeadlessProperty(); // 4. 获取Spring应用run方法的监听器集合并启动所有的监听器 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; // 5. 提供对用于运行SpringApplication的参数的访问 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 6. 创建和配置环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 7. 配置忽略BeanInfo类的加载 configureIgnoreBeanInfo(environment); // 8. 打印Banner Banner printedBanner = printBanner(environment); // 9. 创建ApplicationContext context = createApplicationContext(); // 10. 获取异常报告实例列表 exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); // 11. 准备应用上下文 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 12. 刷新底层的ApplicationContext refreshContext(context); // 13. protected方法，应用上下文刷新后，子类可实现此方法用于后续的操作 afterRefresh(context, applicationArguments); // 14. 打印应用启动信息 stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; // 15. 启动实现了CommandLineRunner 和 ApplicationRunner 接口的类的run方法 listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; // 16. 在run 方法结束之前立即调用，发布事件，应用程序已准备好接受服务请求 listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125;run方法源码上注释了大概流程，接下来继续深入重点流程的源码。流程4，获取Spring应用run方法的监听器集合并启动所有的监听器:getRunListeners(String[] args) 方法源码：12345 private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args));&#125;返回SpringApplicationRunListeners 实例，直接看构造方法的第二个参数的getSpringFactoriesInstances方法实现：1234567891011121314 private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; // 1. 获取类加载器 ClassLoader classLoader = getClassLoader(); // 2. 获取指定类型的工厂实现类的完全限定类名集合 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 3. 根据传入的完全限定类名集合创建对应工厂实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); // 4. 根据工厂实例上的@Order注解指定的顺序排序 AnnotationAwareOrderComparator.sort(instances); return instances;&#125;该方法第一个参数这里传入的是SpringApplicationRunListener 接口，会获取该接口所在类加载器下的“META-INF/spring.factories”属性文件设置的接口实现org.springframework.boot.context.event.EventPublishingRunListener，然后调用该类的构造方法实例化：12345678 public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; this.initialMulticaster = new SimpleApplicationEventMulticaster(); for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; this.initialMulticaster.addApplicationListener(listener); &#125;&#125;该类的主要作用是作为应用启动过程的事件发布监听器，可以看到构造方法中实例化了一个简单的应用事件多播器SimpleApplicationEventMulticaster 并遍历添加应用启动事件监听器。流程4最后调用listeners.starting() 启动监听器，实现源码：12345 @Overridepublic void starting() &#123; this.initialMulticaster.multicastEvent( new ApplicationStartingEvent(this.application, this.args));&#125;该方法多播一个ApplicationStartingEvent实例（应用启动事件），事件源是SpringApplication本身。接下来就是解析事件类型并调用对应的事件监听器了，感兴趣的可以自己深入。深入之前需要对Spring事件机制有所了解，推荐此文Spring事件机制。流程6. 创建和配置环境：prepareEnvironment(listeners, applicationArguments)方法实现：1234567891011121314151617181920 private ConfigurableEnvironment prepareEnvironment( SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // 创建环境 ConfigurableEnvironment environment = getOrCreateEnvironment(); // 配置环境 configureEnvironment(environment, applicationArguments.getSourceArgs()); // 发布环境准备事件 listeners.environmentPrepared(environment); // 绑定环境到此应用 bindToSpringApplication(environment); // 判断是否需要转换环境 if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()) .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; // 附加ConfigurationPropertySource支持到指定环境 ConfigurationPropertySources.attach(environment); return environment;&#125;其中，getOrCreateEnvironment() 方法实现：1234567891011121314 private ConfigurableEnvironment getOrCreateEnvironment() &#123; if (this.environment != null) &#123; return this.environment; &#125; // 根据ClassPath存在的类推断应用运行环境，以下都是web环境 switch (this.webApplicationType) &#123; case SERVLET: return new StandardServletEnvironment(); case REACTIVE: return new StandardReactiveWebEnvironment(); default: return new StandardEnvironment(); &#125;&#125;流程9. 创建ApplicationContext：createApplicationContext方法实现：123456789101112131415161718192021 protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: // 1. 初始化并返回org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext Class对象 contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; // 忽略异常捕获代码 &#125; // 2. 调用AnnotationConfigServletWebServerApplicationContext对象的默认构造方法实例化 return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125;流程11. 准备应用上下文：prepareContext方法实现：123456789101112131415161718192021222324252627282930313233 private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; // 1. 设置环境 context.setEnvironment(environment); // 2. 在ApplicationContext中应用任何相关的后置处理,这里为context对象的BeanFactory实例DefaultListableBeanFactory添加转换服务 postProcessApplicationContext(context); // 3. 在context刷新之前应用实现了ApplicationContextInitializer回调接口的实例进行context上下文对象的初始化 applyInitializers(context); // 4. 发布context初始化事件 listeners.contextPrepared(context); // 5. 打印应用版本信息和激活的配置文件信息active profile if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // 6. 添加名称为springApplicationArguments，springBootBanner的单例bean ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; // 7. 加载源（即main方法所在的类对象）不可变的集合对象并注册其bean到应用上下文 Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[0])); // 8. 发布应用准备事件 listeners.contextLoaded(context);&#125;应用上下文对象准备好了，接下来就进行刷新上下文操作。12. 刷新底层的ApplicationContext：refreshContext方法实现：12345678910 private void refreshContext(ConfigurableApplicationContext context) &#123; refresh(context); if (this.registerShutdownHook) &#123; try &#123; // 向JVM运行时注册一个关机钩子，在JVM关闭时同时关闭这个上下文。 context.registerShutdownHook(); &#125; ...... &#125;&#125;进入到ServletWebServerApplicationContext类的refresh(context)方法实现：1234567 @Overridepublic final void refresh() throws BeansException, IllegalStateException &#123; try &#123; super.refresh(); &#125; ......&#125;发现是直接调用的父类AbstractApplicationContext的refresh方法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 @Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 1. 准备好刷新上下文 prepareRefresh(); // 2. 告诉子类刷新内部bean工厂 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 3. 准备bean工厂以用于此上下文中 prepareBeanFactory(beanFactory); try &#123; // 4. 允许在特定的ApplicationContext实现中注册特殊的bean后置处理器 postProcessBeanFactory(beanFactory); // 5. 实例化并调用所有已注册的BeanFactoryPostProcessor bean invokeBeanFactoryPostProcessors(beanFactory); // 6. 实例化并调用所有已注册的BeanPostProcessor bean registerBeanPostProcessors(beanFactory); // 7. 初始化MessageSource用于当前上下文，提供参数化和i18n的支持 initMessageSource(); // 8. 初始化事件多路广播用于当前上下文，默认使用SimpleApplicationEventMulticaster单例bean initApplicationEventMulticaster(); // 9. 在特定上下文子类中初始化其他特殊bean。 onRefresh(); // 10. 检查监听器bean并注册它们 registerListeners(); // 11. 实例化剩余所有非懒加载的单例bean finishBeanFactoryInitialization(beanFactory); // 12. 最后一步: 发布相应的事件 finishRefresh(); &#125; catch (BeansException ex) &#123; ...... // 销毁所有创建的单例来避免悬空资源 destroyBeans(); // 重置 &apos;active&apos; 标识. cancelRefresh(ex); // 抛出异常给调用者 throw ex; &#125; finally &#123; // 重置Spring的公共反射元数据缓存 resetCommonCaches(); &#125; &#125;&#125;第一点主要做了以下操作：清除本地元数据缓存(如果有的话)，删除所有缓存的类元数据。设置其启动日期和活动标志以及执行任何属性源的初始化。第二点主要做了以下操作：将成员变量 refreshed 设为 true。为 DefaultListableBeanFactory 指定一个用于序列化的id。第三点主要做了以下操作：配置工厂的标准上下文特征，例如上下文的类加载器和后置处理程序。所有bean定义都已加载，但还没有实例化bean。第四点主要做了以下操作：注册特定应用上下文的后置处理器bean扫描basePackage指定的包路径注册被注解的类，例如@Configuration第五点主要做了以下操作：实例化并调用所有已注册的BeanFactoryPostProcessor bean，如果给定显式顺序，则遵循显式顺序分别调用实现了BeanFactoryPostProcessor接口的bean。第六点主要做了以下操作：实例化并调用所有已注册的BeanPostProcessor bean，如果给定显式顺序，则遵循显式顺序分别调用实现了BeanPostProcessor接口的bean。第九点主要做了以下操作：默认创建TomcatWebServer初始化WebApplicationContext和SerlvetContext参数第十一点完成BeanFactory的初始化并实例化剩余的单例bean：finishBeanFactoryInitialization方法实现：12345678910111213141516171819202122232425262728 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // 初始化用于此上下文的转换服务 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; // 如果没有内嵌value解析器Bean则注册一个(例如 PropertyPlaceholderConfigurer bean)，主要用于解析$&#123;&#125;占位符. if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); &#125; // 尽早地初始化LoadTimeWeaverAware bean以允许尽早地注册其变换器 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // 停止正用于类型匹配的临时类加载器 beanFactory.setTempClassLoader(null); // 缓存所有bean定义的元数据，不接受后面的改变 beanFactory.freezeConfiguration(); // 实例化所有剩余的（非懒加载）单例bean beanFactory.preInstantiateSingletons();&#125;其中重点看最后一步preInstantiateSingletons方法的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 @Overridepublic void preInstantiateSingletons() throws BeansException &#123; ...... // 迭代一个beanDefinitionNames的副本以允许init方法，这些方法又轮流注册新的bean定义。 // 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。 List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); // 触发所有非懒加载单例bean的初始化... for (String beanName : beanNames) &#123; RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 如果不是抽象的bean并且是非懒加载的单例bean，则进行 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; // 判断是否是FactoryBean，如果是则进一步判断是否需要尽早的初始化bean，否则直接初始化bean if (isFactoryBean(beanName)) &#123; Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) &#123; final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean; boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; // 触发所有可用单例bean的afterSingletonsInstantiated方法回调... for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125;接下来看getBean(beanName)方法的底层实现，是直接调用doGetBean方法，返回指定bean的实例，该实例可以是共享的或独立的：1234567891011121314151617181920212223242526272829 protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 1. 返回bean名称，必要时删除工厂前缀，并将别名解析为规范名称。 final String beanName = transformedBeanName(name); Object bean; // 2. 急切地检查单例缓存以手动地注册单例 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isTraceEnabled()) &#123; // 3. 判断该当前bean是否在创建中 if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.trace(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.trace(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; &#125; // 4. 获取给定bean实例的对象，如果是FactoryBean，则为bean实例本身或其创建的对象。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 其它情况暂不做深入研究，感兴趣的读者可以自行阅读AbstractBeanFactory#doGetBean方法源码 ...... &#125; return (T) bean;&#125;查看第二点getSingleton方法的实现：123456789101112131415161718192021222324 @Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; Object singletonObject = this.singletonObjects.get(beanName); // 如果从singletonObjects单例bean缓存中获取key为beanName的单例bean为空并且该单例bean // 当前在创建中（在整个工厂内）则从早期已实例化的单例bean缓存earlySingletonObjects中 // 检查beanName的单例对象，如果为空则进一步从singletonFactories单例工厂缓存中获取beanName为key // 的BeanFactory，如果BeanFactory不为空则获取到其管理的单例bean实例并将其缓存 // 到earlySingletonObjects对象上，最后从singletonFactories缓存中移除管理该beanName // 实例的BeanFactory对象（解决循环引用） if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject;&#125;几个重要对象说明：singletonObjects：单例bean对象的缓存，ConcurrentHashMap-&gt;{beanName:beanInstance}earlySingletonObjects: 早期的单例bean对象的缓存，HashMap-&gt;{beanName:beanInstance}singletonFactories：单例BeanFactory的缓存，HashMap-&gt;{beanName:beanFactory}, beanFactory-&gt;beanInstance查看第四点getObjectForBeanInstance方法的实现：123456789101112131415161718192021222324252627282930313233343536 protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // bean的name如果以&amp;开头，则是FactoryBean实例 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; // 验证是否是FactoryBean对象，不是则抛出异常 if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; &#125; // 执行到此处，已经得到了bean实例，如果是普通的bean，或者是FacoryBean实例，直接返回. if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; // 从FactoryBeanObjectCache中获取由FactoryBean创建的bean对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // beanInstance强转为FactoryBean FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // 如果是单例，则缓存从FactoryBean获取的对象 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); // 最终调用FactoryBean实例的getObject方法获取bean实例 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125;回到refresh方法的第十二点，最后完成上下文的刷新操作，调用LifecycleProcessor的onRefresh方法并且发布最终的ContextRefreshedEvent事件：12345678910111213141516 protected void finishRefresh() &#123; // 清除此资源加载器中的所有资源缓存。 clearResourceCaches(); // 初始化此上下文的生命周期处理器DefaultLifecycleProcessor。 initLifecycleProcessor(); // 调用DefaultLifecycleProcessor的onRefresh方法 getLifecycleProcessor().onRefresh(); // 发布最终的ContextRefreshedEvent事件 publishEvent(new ContextRefreshedEvent(this)); // 如果激活则参与到LiveBeansView MBean中 LiveBeansView.registerApplicationContext(this);&#125;子类finishRefresh方法最后启动相应的WebServer并发布事件。12345678 @Overrideprotected void finishRefresh() &#123; super.finishRefresh(); WebServer webServer = startWebServer(); if (webServer != null) &#123; publishEvent(new ServletWebServerInitializedEvent(webServer, this)); &#125;&#125;以上就是Spring Boot启动流程源码分析的完整内容，如果有问题欢迎提出！]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>doGetBean</tag>
        <tag>refreshContext</tag>
        <tag>refresh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbitmq Network Partitions 网络分区解决方案]]></title>
    <url>%2F2019%2F04%2F04%2FRabbitmq-Network-Partitions-%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[高可用集群环境（镜像模式）：双节点：rabbit@rabbit1（master）、rabbit@rabbit2（slave）集群设置：rabbit1控制台：123rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_app将节点2加入到集群，rabbit2控制台：1234rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbit@rabbit1rabbitmqctl start_app参数“—ram”表示设置为内存节点，忽略此参数则默认为磁盘节点。可以用命令rabbitmqctl change_cluster_node_type disc改变节点类型，需要注意的是集群环境中至少有一个为磁盘节点最后查看集群状态：1234567root@rabbit2:/# rabbitmqctl cluster_statusCluster status of node rabbit@rabbit2 ...[&#123;nodes,[&#123;disc,[rabbit@rabbit1]&#125;,&#123;ram,[rabbit@rabbit2]&#125;]&#125;, &#123;running_nodes,[rabbit@rabbit1,rabbit@rabbit2]&#125;, &#123;cluster_name,&lt;&lt;&quot;rabbit@rabbit-cluster&quot;&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@rabbit1,[]&#125;,&#123;rabbit@rabbit2,[]&#125;]&#125;]首先解决网络分区导致队列不可用的问题，需要先设置队列的高可用策略，在任意mq节点控制台执行命令：1rabbitmqctl set_policy -p / ha-all &quot;^&quot; &apos;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;-p 指定vhost“^” 指定策略匹配到所有队列然后进入rabbit1控制台，编辑mq配置分区恢复处理策略：1root@rabbit1:/# vim /etc/rabbitmq/rabbitmq.conf添加以下内容：123456789## 指定网络分区处理策略cluster_partition_handling = pause_if_all_down## Recovery strategy. Can be either &apos;autoheal&apos; or &apos;ignore&apos;cluster_partition_handling.pause_if_all_down.recover = autoheal## Node names to checkcluster_partition_handling.pause_if_all_down.nodes.1 = rabbit@rabbit1cluster_partition_handling.pause_if_all_down.nodes.2 = rabbit@rabbit2RabbitMQ提供了4种处理网络分区的方式：ignore 默认，RabbitMQ不会自动做任何处理，即需要手动处理。pause_minority 这种处理方式适合集群节点数大于2个且最好为奇数的情况，因为当网络恢复时，有可能两个节点会自动启动恢复网络分区，也有可能还是保持关闭状态。pause_if_all_down, [nodes], ignore|autoheal RabbitMQ会自动关闭不能和[nodes]中节点通信的节点。autoheal RabbitMQ会自动决定一个获胜的（winning）分区，然后重启不在这个分区中的节点以恢复网络分区。最后重启节点1，使策略生效。]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Network Partitions</tag>
        <tag>网络分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
